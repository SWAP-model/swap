var tipuesearch = {"pages":[{"title":" API reference SWAP ","text":"API reference SWAP Developer Info Multiple Authors","tags":"home","loc":"index.html"},{"title":"FUNC – API reference SWAP","text":"function FUNC(x, Capac_term, Nmin1, Mplus1, alpha, gen_n, surface_tension_water) !!! func= -(( -(sat_water_cont - res_water_cont) * alpha *            & !!!&      ( (ax) (gen_n - 1.d0) ) *                                  &\n!!!&      ( ( 1.d0 + axn ) (gen_m - 1.d0) ) &\n!!!&      gen_m gen_n ) /                                             &\n!!!&      (((( axn ) + 1.d0 ) gen_m) 2) ) /                         &\n!!!&      (pi4 (((surface_tension_water 2)/(x 2))))\n! func= -( -(sat_water_cont - res_water_cont) * alpha *            & !&      ( (ax) (gen_n - 1.d0) ) *                                  &\n!&      ( ( 1.d0 + axn ) (-gen_m - 1.d0) ) &\n!&      gen_m gen_n ) /                                             &\n!&      (pi4 (((surface_tension_water 2)/(x 2)))) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: Capac_term real(kind=8) :: Nmin1 real(kind=8) :: Mplus1 real(kind=8) :: alpha real(kind=8) :: gen_n real(kind=8) :: surface_tension_water Return Value real(kind=8)","tags":"","loc":"proc/func.html"},{"title":"FUNCtab – API reference SWAP","text":"function FUNCtab(x, diff_water_cap, surface_tension_water) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: diff_water_cap real(kind=8) :: surface_tension_water Return Value real(kind=8)","tags":"","loc":"proc/functab.html"},{"title":"SOLVE – API reference SWAP","text":"function SOLVE(xi, accuracy) Uses O2_pars Arguments Type Intent Optional Attributes Name real(kind=8) :: xi real(kind=8) :: accuracy Return Value real(kind=8)","tags":"","loc":"proc/solve.html"},{"title":"myfunc – API reference SWAP","text":"function myfunc(x) Uses O2_pars Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8)","tags":"","loc":"proc/myfunc.html"},{"title":"ZBREND – API reference SWAP","text":"function ZBREND(FUNC, X1, X2, FA, FB, TOL) Arguments Type Intent Optional Attributes Name double precision :: FUNC double precision :: X1 double precision :: X2 double precision :: FA double precision :: FB double precision :: TOL Return Value doubleprecision","tags":"","loc":"proc/zbrend.html"},{"title":"OxygenStress – API reference SWAP","text":"subroutine OxygenStress(node, rwu_factor) Uses variables O2_pars Arguments Type Intent Optional Attributes Name integer :: node real(kind=8) :: rwu_factor","tags":"","loc":"proc/oxygenstress.html"},{"title":"GET_MAX_RESP_FACTOR – API reference SWAP","text":"subroutine GET_MAX_RESP_FACTOR(Max_resp_factor_gmrf) Uses Variables Arguments Type Intent Optional Attributes Name real(kind=8) :: Max_resp_factor_gmrf","tags":"","loc":"proc/get_max_resp_factor.html"},{"title":"TEMP_DEPENDENT_PARAMETERS – API reference SWAP","text":"subroutine TEMP_DEPENDENT_PARAMETERS(d_o2inwater, d_root, d_gassfreeair, surface_tension_water, bunsencoeff, soil_temp) Arguments Type Intent Optional Attributes Name real(kind=8) :: d_o2inwater real(kind=8) :: d_root real(kind=8) :: d_gassfreeair real(kind=8) :: surface_tension_water real(kind=8) :: bunsencoeff real(kind=8) :: soil_temp","tags":"","loc":"proc/temp_dependent_parameters.html"},{"title":"TRAPZD – API reference SWAP","text":"subroutine TRAPZD(a, b, s, n, Capac_term, Nmin1, Mplus1, alpha, gen_n, surface_tension_water, glit) Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b real(kind=8) :: s integer :: n real(kind=8) :: Capac_term real(kind=8) :: Nmin1 real(kind=8) :: Mplus1 real(kind=8) :: alpha real(kind=8) :: gen_n real(kind=8) :: surface_tension_water integer :: glit","tags":"","loc":"proc/trapzd.html"},{"title":"TRAPZDtab – API reference SWAP","text":"subroutine TRAPZDtab(a, b, s, n, diff_water_cap, surface_tension_water, glit) Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b real(kind=8) :: s integer :: n real(kind=8) :: diff_water_cap real(kind=8) :: surface_tension_water integer :: glit","tags":"","loc":"proc/trapzdtab.html"},{"title":"waterfilmthickness – API reference SWAP","text":"subroutine waterfilmthickness(waterfilm_thickness, matric_potential, Capac_term, Nmin1, Mplus1, alpha, gen_n, surface_tension_water, glit, soilphystab, diff_water_cap_actual, numrec_tab) Uses Variables doln !!sptab(1,node,ii) = soilphystab(1,ii) Arguments Type Intent Optional Attributes Name real(kind=8) :: waterfilm_thickness real(kind=8) :: matric_potential real(kind=8) :: Capac_term real(kind=8) :: Nmin1 real(kind=8) :: Mplus1 real(kind=8) :: alpha real(kind=8) :: gen_n real(kind=8) :: surface_tension_water integer :: glit real(kind=8) :: soilphystab (7,matab) real(kind=8) :: diff_water_cap_actual integer :: numrec_tab","tags":"","loc":"proc/waterfilmthickness.html"},{"title":"microbial_resp – API reference SWAP","text":"subroutine microbial_resp(r_microbial_z0, soil_temp, perc_org_mat, soil_density, percentage_sand, matric_potential, specific_resp_humus, q10_microbial) Arguments Type Intent Optional Attributes Name real(kind=8) :: r_microbial_z0 real(kind=8) :: soil_temp real(kind=8) :: perc_org_mat real(kind=8) :: soil_density real(kind=8) :: percentage_sand real(kind=8) :: matric_potential real(kind=8) :: specific_resp_humus real(kind=8) :: q10_microbial","tags":"","loc":"proc/microbial_resp.html"},{"title":"MICRO – API reference SWAP","text":"subroutine MICRO(c_mroot, w_root, f_senes, q10_root, soil_temp, sat_water_cont, gas_filled_porosity, d_o2inwater, d_root, perc_org_mat, soil_density, specific_resp_humus, q10_microbial, depth, shape_factor_microbialr, root_radius, waterfilm_thickness, bunsencoeff, c_min_micro, resp_factor) Arguments Type Intent Optional Attributes Name real(kind=8) :: c_mroot real(kind=8) :: w_root real(kind=8) :: f_senes real(kind=8) :: q10_root real(kind=8) :: soil_temp real(kind=8) :: sat_water_cont real(kind=8) :: gas_filled_porosity real(kind=8) :: d_o2inwater real(kind=8) :: d_root real(kind=8) :: perc_org_mat real(kind=8) :: soil_density real(kind=8) :: specific_resp_humus real(kind=8) :: q10_microbial real(kind=8) :: depth real(kind=8) :: shape_factor_microbialr real(kind=8) :: root_radius real(kind=8) :: waterfilm_thickness real(kind=8) :: bunsencoeff real(kind=8) :: c_min_micro real(kind=8) :: resp_factor","tags":"","loc":"proc/micro.html"},{"title":"MACRO – API reference SWAP","text":"subroutine MACRO(c_macro, depth, resp_factor, c_mroot, w_root_z0, f_senes, q10_root, soil_temp, ctop, shape_factor_microbialr, shape_factor_rootr, r_microbial_z0, d_soil) Arguments Type Intent Optional Attributes Name real(kind=8) :: c_macro real(kind=8) :: depth real(kind=8) :: resp_factor real(kind=8) :: c_mroot real(kind=8) :: w_root_z0 real(kind=8) :: f_senes real(kind=8) :: q10_root real(kind=8) :: soil_temp real(kind=8) :: ctop real(kind=8) :: shape_factor_microbialr real(kind=8) :: shape_factor_rootr real(kind=8) :: r_microbial_z0 real(kind=8) :: d_soil","tags":"","loc":"proc/macro.html"},{"title":"oxygen_dat – API reference SWAP","text":"subroutine oxygen_dat(SwTopSub, NrStaring, OxygenSlope, OxygenIntercept) Arguments Type Intent Optional Attributes Name integer :: SwTopSub integer :: NrStaring real(kind=8) :: OxygenSlope (6) real(kind=8) :: OxygenIntercept (6)","tags":"","loc":"proc/oxygen_dat.html"},{"title":"OxygenReproFunction – API reference SWAP","text":"subroutine OxygenReproFunction(OxygenSlope, OxygenIntercept, theta, thetas, tsoil, node, z, dz, rwu_factor) Uses variables Arguments Type Intent Optional Attributes Name real(kind=8) :: OxygenSlope (6) real(kind=8) :: OxygenIntercept (6) real(kind=8) :: theta (macp) real(kind=8) :: thetas (macp) real(kind=8) :: tsoil (macp) integer :: node real(kind=8) :: z (macp) real(kind=8) :: dz (macp) real(kind=8) :: rwu_factor","tags":"","loc":"proc/oxygenreprofunction.html"},{"title":"QROMBD – API reference SWAP","text":"subroutine QROMBD(a, b, ss, Capac_term, Nmin1, Mplus1, alpha, gen_n, surface_tension_water, glit) Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b real(kind=8) :: ss real(kind=8) :: Capac_term real(kind=8) :: Nmin1 real(kind=8) :: Mplus1 real(kind=8) :: alpha real(kind=8) :: gen_n real(kind=8) :: surface_tension_water integer :: glit","tags":"","loc":"proc/qrombd.html"},{"title":"QROMBDtab – API reference SWAP","text":"subroutine QROMBDtab(a, b, ss, dif_water_cap, surface_tension_water, glit) Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b real(kind=8) :: ss real(kind=8) :: dif_water_cap real(kind=8) :: surface_tension_water integer :: glit","tags":"","loc":"proc/qrombdtab.html"},{"title":"POLINTD – API reference SWAP","text":"subroutine POLINTD(XA, YA, N, X, Y, DY) Arguments Type Intent Optional Attributes Name real(kind=8), dimension(n) :: XA real(kind=8), dimension(n) :: YA integer :: N real(kind=8) :: X real(kind=8) :: Y real(kind=8) :: DY","tags":"","loc":"proc/polintd.html"},{"title":"checkmassbal – API reference SWAP","text":"subroutine checkmassbal(FlOpenFileDev, inqdraNew, IQExcMtxDm1CpNew, IQExcMtxDm2CpNew, inqNew, IQOutDrRapCpNew, inqrotNew, IThetaBegNew, thetaNew) Uses variables Arguments Type Intent Optional Attributes Name logical :: FlOpenFileDev real(kind=8) :: inqdraNew (Madr,macp) real(kind=8) :: IQExcMtxDm1CpNew (macp) real(kind=8) :: IQExcMtxDm2CpNew (macp) real(kind=8) :: inqNew (macp+1) real(kind=8) :: IQOutDrRapCpNew (macp) real(kind=8) :: inqrotNew (macp) real(kind=8) :: IThetaBegNew (MaCp) real(kind=8) :: thetaNew (macp)","tags":"","loc":"proc/checkmassbal.html"},{"title":"BoundBottom – API reference SWAP","text":"subroutine BoundBottom() Uses variables \\brief Determines the soil profile bottom boundary conditions. This subroutine calculates the boundary conditions at the bottom of a soil profile.\nIt handles various cases such as given groundwater level, regional bottom flux, \nseepage or infiltration from/to deep groundwater, zero flux, free drainage, and \nlysimeter with free drainage. \\date August 2004 / Sept 2005 Arguments None","tags":"","loc":"proc/boundbottom.html"},{"title":"TRIDAG – API reference SWAP","text":"subroutine TRIDAG(n, a, b, c, r, u, ierror) Date      : 15/9/99 Purpose:    Solves for a vector U a tridiagonal linear set.         *\n References:                                                         *\n Press, W.H., B.P. Flannery, S.A. Teukolsky & W.T. Vetterling, 1989. *\n Numerical Recipes in FORTRAN. Cambridge University Press, New York. *\n pp 40-41                                                            * Input:     N -      Number of equations                             *\n            A,B,C -  Coefficients of the matrix                      *\n            R -      known vector                                    *\n Output:    U -      solved vector                                   * Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: a (n) real(kind=8) :: b (n) real(kind=8) :: c (n) real(kind=8) :: r (n) real(kind=8) :: u (n) integer :: ierror","tags":"","loc":"proc/tridag.html"},{"title":"bandec – API reference SWAP","text":"subroutine bandec(a, n, m1, m2, np, mp, al, mpl, indx, d) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (np,mp) integer :: n integer :: m1 integer :: m2 integer :: np integer :: mp real(kind=8) :: al (np,mpl) integer :: mpl integer :: indx (n) real(kind=8) :: d","tags":"","loc":"proc/bandec.html"},{"title":"banbks – API reference SWAP","text":"subroutine banbks(a, n, m1, m2, np, mp, al, mpl, indx, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (np,mp) integer :: n integer :: m1 integer :: m2 integer :: np integer :: mp real(kind=8) :: al (np,mpl) integer :: mpl integer :: indx (n) real(kind=8) :: b (n)","tags":"","loc":"proc/banbks.html"},{"title":"STRinARSTR – API reference SWAP","text":"function STRinARSTR(string, arraystring, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), dimension(N) :: arraystring integer, intent(in) :: N Return Value logical","tags":"","loc":"proc/strinarstr.html"},{"title":"writeheader – API reference SWAP","text":"subroutine writeheader(iun) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iun","tags":"","loc":"proc/writeheader.html"},{"title":"my_piksrt – API reference SWAP","text":"subroutine my_piksrt(n, arr, brr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(inout), dimension(n) :: arr character(len=*), intent(inout), dimension(n) :: brr","tags":"","loc":"proc/my_piksrt.html"},{"title":"csv_out – API reference SWAP","text":"public  subroutine csv_out(iTask) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iTask","tags":"","loc":"proc/csv_out.html"},{"title":"csv_out_tz – API reference SWAP","text":"public  subroutine csv_out_tz(iTask) Uses variables Arguments Type Intent Optional Attributes Name integer, intent(in) :: iTask","tags":"","loc":"proc/csv_out_tz.html"},{"title":"O2_pars – API reference SWAP","text":"Uses variables Variables Type Visibility Attributes Name Initial real(kind=8), public, save :: w_root real(kind=8), public, save :: w_root_z0 real(kind=8), public, save :: soil_temp real(kind=8), public, save :: sat_water_cont real(kind=8), public, save :: gas_filled_porosity real(kind=8), public, save :: d_o2inwater real(kind=8), public, save :: d_root real(kind=8), public, save :: perc_org_mat real(kind=8), public, save :: soil_density real(kind=8), public, save :: d_soil real(kind=8), public, save :: depth real(kind=8), public, save :: shape_factor_microbialr real(kind=8), public, save :: root_radius real(kind=8), public, save :: r_microbial_z0 real(kind=8), public, save :: waterfilm_thickness real(kind=8), public, save :: bunsencoeff real(kind=8), public, save :: c_min_micro real(kind=8), public, save :: c_macro real(kind=8), public, save :: ctopnode","tags":"","loc":"module/o2_pars.html"},{"title":"SWAP_csv_output – API reference SWAP","text":"Uses variables Subroutines public  subroutine csv_out (iTask) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iTask","tags":"","loc":"module/swap_csv_output.html"},{"title":"SWAP_csv_output_tz – API reference SWAP","text":"Subroutines public  subroutine csv_out_tz (iTask) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iTask","tags":"","loc":"module/swap_csv_output_tz.html"},{"title":"oxygenstress.f90 – API reference SWAP","text":"Source Code ! File VersionID: !   $Id: oxygenstress.f90 378 2018-05-08 13:50:52Z heine003 $ ! ! ---------------------------------------------------------------------- ! ## MH: December 2017 ! Changes to optimize performance of routine OxygenStress. ! In summary: !  * certain repeatedly calculated constants have been predefined as constant parameters for further use: !        Fac3230 = 32.0d0/30.0d0 !        d_o2inwater_ref = 1.0d-5*1.2d0/(100.0d0*100.0d0) !        SecsPerDay = 24.0d0*3600.0d0 !        Tref3 = 1.0d0/(293.0d0**3) !        pi4 = 4.0d0*pi !        h1        =   25000.0d0 !        h2        =  762500.0d0 !        h3        = 1500000.0d0 !        log10h1   = dlog10(h1) !        log10h2   = dlog10(h2) !        log10h3   = dlog10(h3) !        log10h3h2 = log10h3 - log10h2 !        FourThird = 4.0d0/3.0d0 !  * Since division is slower than multiplication, where relevant changes were made; e.g. /10.0 = 0.1* !  * Other change: ()**0.5 replaced by sqrt() !  * For the calculation of d_soil, constant properties per node were repeatedly calcuated. !        New: this has been done only once (routine calc_ini_pars) and these properties were stored !             for all nodes (1..numnod) !  * From a profiling analysis it became evident that the numerical integration in the routine !    waterfilmthickness was a high-demanding CPU unit. !        The originally chosen method, trapezoidal rule, is straightforward and robust. !        If we assume that our function is sufficiently smooth and has no singularities (also not at the end points) !        then it is better to use the Romberg Integration method (see Press et al., 1987, Numerical Recipes). !        This method takes \"many, many fewer\" function evaluations than the trapezoidal rule alone, !        even though the Romberg method makes use of the trapezoidal rule itself. !        Implementation of this method decreased the CPU time drastically for a loam case study. !        Currently both methods are still present in the code, and can be switched by a logical parameter flag !        that is defined in the subroutine waterfilmthickness: !           flUseQromb = .true. (use Romberg integration; else use orginal trapezoidal integration) !  * For convenience, filling the table ResultsOxStr has been disabled, and the code has been moved !    to separate routines (FillOxygenStress1, FillOxygenStress2). First reason: the output was never used !    in the remainder of SWAP, so it was assumed that this table was only used for debugging purposes. !    Second remark: this table was defined in file Variables.f90, and again locally here. This could be improved !    if still needed in the future. !  * Function FUNC makes use of the derivative of the water retention curve. The equation provided in !    Bartholomeus et al. (2008; J. Hydrol 360:147-165; their appendix A.4) can be further simplified given by: !        C = (sat_water_cont - res_water_cont) * alpha * ( (ax)**(gen_n - 1.d0) ) * ( ( 1.d0 + axn )**(-gen_m - 1.d0) )* gen_m*gen_n !           where ax = alpha*x and axn = (alpha*x)**gen_n !    Therefore, initially three constants per node are calculated ands stored for later use: !        Capac_term(i) = (WCs-WCr)*Alpha*N*M !        Nmin1(i)      = N-1 !        Mplus1(i)     = M+1 !  * Two constants initially set in Calc_ini_pars: shape_factor_microbialr, shape_factor_rootr !  * An alternative solution for function SOLVE has been implemented: using ZBREND from Numerical Recipes (Press et al., 1987). !        In function SOLVE the programmer can switch between original approach (Newton-Raphson) or !        the new approach (ZBREND) via a logical parameter (useZBREND). !        New method resulted in negligable differences, but is somewhat faster. !        For the implementation of the ZBREND method with the required defintion of a function (myfunc) !        it was helpful to move a large number of variables into a module (O2_pars). In this way it was !        prevented to carry-over a large number of arguments from SOLVE to ZBREND to myfunc. !        In principle, O2_pars can also bue used in other routines/functions resulting in less arguments !        in their calls. This has not yet been implemented. module O2_pars use variables , only : c_mroot , f_senes , max_resp_factor , q10_root , q10_microbial , shape_factor_rootr , specific_resp_humus , ztopcp real ( 8 ), save :: w_root , w_root_z0 real ( 8 ), save :: soil_temp real ( 8 ), save :: sat_water_cont , gas_filled_porosity real ( 8 ), save :: d_o2inwater , d_root , perc_org_mat , soil_density real ( 8 ), save :: d_soil real ( 8 ), save :: depth real ( 8 ), save :: shape_factor_microbialr , root_radius real ( 8 ), save :: r_microbial_z0 real ( 8 ), save :: waterfilm_thickness , bunsencoeff real ( 8 ), save :: c_min_micro , c_macro , ctopnode end module O2_pars ! ## MH      subroutine OxygenStress(node,rwu_factor,ResultsOxStr) subroutine OxygenStress ( node , rwu_factor ) ! ---------------------------------------------------------------------- !     Last modified      : January 2014 !     Purpose            : calculates oxygen stress according to Bartholomeus et al. (2008) ! ---------------------------------------------------------------------- use variables use O2_pars , only : w_root , w_root_z0 , soil_temp , sat_water_cont , gas_filled_porosity , d_o2inwater , d_root , & perc_org_mat , soil_density , depth , shape_factor_microbialr , root_radius , waterfilm_thickness , & bunsencoeff , c_min_micro , c_macro , ctopnode , r_microbial_z0 , d_soil implicit none ! --- local integer glit , lay , node , i , j real ( 8 ) resp_factor , rwu_factor , xi , accuracy real ( 8 ) theta0 real ( 8 ) matric_potential real ( 8 ) air_temp , alpha , d_gassfreeair , gen_n , o2_atmosphere , percentage_sand , surface_tension_water real ( 8 ) SOLVE , pi real ( 8 ) soilphystab ( 7 , matab ) real ( 8 ) diff_water_cap_actual integer numrec_tab real ( 8 ) rdepth , rdens , afgen !RB20140110 real ( 8 ) rdepth_top , rdens_top !RB20140114 ! ## MH : why ResultsOxStr as argument and locally stored, whereas ResultsOxygenStress was already globally defined in varibles ??? ! ## MH      real(8) ResultsOxStr(19,macp)    ! result oxygen stress; tabulated for each model compartment ! ## MH : calcluations ResultsOxStr disabled because it is never used anywhere in SWAP ! ## MH : alternative use switch (flag) to choose whether or not to calculate ResultsOxStr (for debugging purposes) real ( 8 ) top1 , top2 parameter ( pi = 3.1415926535d0 ) real ( 8 ), parameter :: Fac3230 = 3 2.0d0 / 3 0.0d0 ! ## MH real ( 8 ), dimension ( macp ) :: d_soil_term1 , d_soil_term2 , gfp100 real ( 8 ), dimension ( macp ) :: Capac_term , Nmin1 , Mplus1 logical :: ini = . true . !     save values of locals save !save   waterfilm_thickness,r_microbial_z0,d_soil !save   d_soil_term1, d_soil_term2, ini, gfp100 !## MH : some initial calculations if ( ini ) then if ( iHWCKmodel ( layer ( node )) == 3 ) then call fatalerr ( 'OxygenStress' , 'Combination of OxygenStress and bi-modal MvG (iHWCKmodel=3) is not (yet) possible!' ) end if call calc_ini_pars ( numnod ) ini = . false . end if !## MH: end ! --- Get max_resp_factor, i.e. the ratio between total respiration and maintenance respiration if ( node . eq . 1 ) call GET_MAX_RESP_FACTOR ( max_resp_factor ) ! --- initialize c_min_micro = 0.1d0 c_macro = 0.2d0 resp_factor = 1.0d0 ! --- soil layer in SWAP lay = layer ( node ) ! --- dry weight of root per unit length of root [kg/m] w_root = 1.0d0 / SRL ! --- root radius [m]                  ## MH: ()**0.5 replaced by dsqrt() if ( swrootradius . eq . 1 ) then root_radius = dsqrt (( w_root / ( pi * dry_mat_cont_roots * & & ( 1 - air_filled_root_por ) * spec_weight_root_tissue )) - & & ( var_a )) endif if ( swrootradius . eq . 2 ) then root_radius = root_radiusO2 endif ! --- RB20140117 get wofost parameters if (( croptype ( icrop ) . eq . 2 ). or .( croptype ( icrop ) . eq . 3 )) then q10_root = q10 c_mroot = rmr * Fac3230 !CH2O --> O2 endif if ( croptype ( icrop ) . eq . 2 ) then f_senes = afgen ( rfsetb , 30 , dvs ) endif if ( croptype ( icrop ) . eq . 3 ) then f_senes = afgen ( rfsetb , 30 , rid ) endif ! --- extract a number of variables from Swap for local use in module OxygenStress ! --- set soil density [kg m-3] soil_density = bdens ( lay ) ! --- set parameter n of soil hydraulic functions gen_n = cofgen ( 6 , node ) ! --- set saturated water content [-] sat_water_cont = cofgen ( 2 , node ) ! --- set parameter alpha [1/Pa] of soil hydraulic functions, so divide main swap alpha by 100     ## MH: =0.01* alpha = 0.01d0 * cofgen ( 4 , node ) ! --- set percentage organic matter [%] perc_org_mat = orgmat ( lay ) * 10 0.0d0 ! --- set percentage sand in % of total soil percentage_sand = ( psand ( lay ) * ( 1.0d0 - orgmat ( lay ))) * 10 0.0d0 ! --- get soil moisture content as defined in further calculations within this routine [-] theta0 = theta ( node ) ! --- gas filled porosity gas_filled_porosity = sat_water_cont - theta0 if ( h ( node ) >= 0.0d0 ) gas_filled_porosity = 0.0d0 ! be sure when saturated that gas_filled_porosity = 0 ! --- thickness of the soil compartment [m]     ## MH: =0.01* depth = 0.01d0 * dz ( node ) ! --- temperature in the soil compartment [K] soil_temp = tsoil ( node ) + 27 3.d0 ! --- dry weight of roots at nodal depth !RB20140109 start new calculation of w_root_z0 !previous:  w_root_z0 = w_root_ss * exp(0.01*z(node)/shape_factor_rootr) !new: ! --- static crop. w_root_z0 relative to value of top layer if ( croptype ( icrop ) . eq . 1 ) then rdepth_top = - ztopcp ( 1 ) / rd ! (-z(1)-0.5d0*dz(1))/rd rdens_top = afgen ( rdctb , 22 , rdepth_top ) rdepth = - ztopcp ( node ) / rd ! (-z(node)-0.5d0*dz(node))/rd rdens = afgen ( rdctb , 22 , rdepth ) w_root_z0 = w_root_ss * rdens / rdens_top !static crop endif ! --- calculate wrootz0 [kg/m3] at top of the compartments !adj RB 20171201 ! --- dynamic crop. wrt [kg/ha] = 10-4 kg/m2; if (( croptype ( icrop ) . eq . 2 ) . or . ( croptype ( icrop ) . eq . 3 )) then top1 = dabs ( ztopcp ( node ) / rd ) ! relative depth top top2 = top1 + 1.0d-6 ! define 'infinite' thin layer; fraction w_root_z0 = 1.0d6 * & ! rescale fraction to 1 (top 2) & ( afgen ( cumdens , 202 , top2 ) - afgen ( cumdens , 202 , top1 )) * & ! fraction & ( wrt * 0.0001d0 * ( 1.0d0 / ( 0.01d0 * rd ))) ! wrt kg/ha --> kg/m2; rd cm -> m endif !JKRO20171114_temp output for testing only !      write(99,'(f15.7,a1,i5,a1,i5,a1,f10.3,a1,e12.3)')                   & !     &  t1900,\",\",node,\",\",nint(dz(node)),\",\",z(node),\",\",w_root_z0 ! --- Calculate matric potential [Pa] matric_potential = - 10 0.0d0 * h ( node ) ! --- if gas filled porosity = 0, then root water uptake = 0. Store results and go to end of routine. if ( gas_filled_porosity . lt . 1.0d-4 ) then !RB20131106 .eq. 0 ! RB 20140106 start if statement added; if max_resp_factor = 1 then no stress so rwufactor = 1 if ( max_resp_factor . gt . 1.0d0 ) then rwu_factor = 0.0d0 else rwu_factor = 1.0d0 endif c_macro = 0.d0 !RB20140825 added ! --- store value for output results call FillOxygenStress1 () else ! (if (gas_filled_porosity .lt. 1.0d-6)) ! --- In case of tabular soil hydraulic functions if ( swsophy . eq . 1 ) then ! --- Get tabular soil hydraulic function for node do i = 1 , 7 do j = 1 , numtablay ( lay ) !check this soilphystab ( i , j ) = sptab ( i , node , j ) end do end do ! --- Get differential water capacity at actual node, (/L --> /Pa) diff_water_cap_actual = 0.01d0 * dimoca ( node ) numrec_tab = j - 1 endif ! --- atmosphere oxygen concentration [kg/m3] according to general gas law if ( node . eq . 1 ) then ! ---   atmospheric temperature [K] air_temp = tav + 27 3.0d0 o2_atmosphere = ( 67 2.0d0 ) / ( 8.314472d0 * air_temp ) ! ---   PLAATS O2_atmosphere IN DE VECTOR VOOR C_TOP C_top ( 1 ) = o2_atmosphere endif ! --- Calculate temperature dependent parameters call TEMP_DEPENDENT_PARAMETERS ( d_o2inwater , d_root , & d_gassfreeair , surface_tension_water , bunsencoeff , soil_temp ) ! --- Calculate diffusivity Dsoil !## MH: d_soil_term1, d_soil_term2 and gfp100 were initially calculated and stored per node d_soil = d_gassfreeair * d_soil_term1 ( node ) * & & (( gas_filled_porosity / gfp100 ( node )) ** d_soil_term2 ( node )) !## MH: end ! --- Calculate the thickness of the water film that surrounds the roots call waterfilmthickness ( waterfilm_thickness , & & matric_potential , Capac_term ( node ), Nmin1 ( node ), Mplus1 ( node ), & & alpha , gen_n , surface_tension_water , glit , & & soilphystab , diff_water_cap_actual , numrec_tab ) ! --- Calculate microbial respiration rate call microbial_resp ( r_microbial_z0 , soil_temp , perc_org_mat , & & soil_density , percentage_sand , matric_potential , & & specific_resp_humus , q10_microbial ) ! --- Calculate sink term variable ! --- Define input for the solving procedure xi = 0.5d0 * max_resp_factor accuracy = 1.0d-4 ctopnode = c_top ( node ) ! --- Calculate actual respiration factor from the solving procedure resp_factor = SOLVE ( xi , accuracy ) ! --- PLAATS C_MACRO IN DE VECTOR VOOR C_TOP. BEREKENDE WAARDE IS INPUT VOOR VOLGENDE COMPARTIMENT C_top ( node + 1 ) = C_macro ! --- Calculate the sink term (Root Water Uptake) variable due to oxygen stress. ! --- The decrease in root water uptake is assumed proportional to the decrease ! --- in respiration (given by the maximum and actual respiration factor). ! RB 20140106 start if statement added; if max_resp_factor = 1 then no stress so rwufactor = 1 if ( max_resp_factor . gt . 1.0d0 ) then rwu_factor = ( 1.0d0 / ( max_resp_factor - 1.0d0 )) * resp_factor & & - ( 1.0d0 / ( max_resp_factor - 1.0d0 )) else ! Ruud Bartholomeus: 19-12-2017 ! Wat betreft zuurstofstress als er geen enkele groei van de wortels meer is: ! -  De lineaire afname van RWU met afname van groeirespiratie van de wortels moeten we handhaven. Rwu_factor = 1 als groeirespiratie is optimaal, rwu_factor = 0 als geen groeirespiratie. ! -  Als er geen groeirespiratie van de wortels meer is, maar wel groei van bovengrondse delen is er nog wel transpiratie en dus wateropname van de wortels ! -  Als er geen groeirespiratie van de wortels meer nodig is, maar er wel voldoende zuurstof is voor onderhoudsrespiratie, dan functioneren de wortels dus zoals het moet en nemen ook water op. Als er onvoldoende zuurstof is voor onderhoudsrespiratie van de wortels, dan sterven deze. Ze nemen dan geen water op. ! -  Voorstel voor verbetering in de code: !        o  Als max_resp_factor = 1 en resp_factor < 1 DAN rwu_factor = 0 !        o  Hier zit dus geen geleidelijke afname: onvoldoende zuurstof voor onderhoud = stop if ( resp_factor < 1.0d0 ) then rwu_factor = 0.0d0 !## MH: suggested by RB 19-12-2017: rwu_factor = 0  : orignal code before 19-12-2017: rwu_factor = 1.0d0 else rwu_factor = 1.0d0 end if endif ! RB 20140106 end if statement added if ( rwu_factor . gt . 1.0d0 ) then rwu_factor = 1.0d0 endif if ( rwu_factor . lt . 0.d0 ) then rwu_factor = 0.d0 endif endif !if (gas_filled_porosity .lt. 1.0d-6) !RB20131216 goto removed ! --- store value for output results call FillOxygenStress2 () return contains subroutine calc_ini_pars ( numnod ) !## MH : these constant can be calculated only once at initial call to OxygenStress !## MH : results are stored and saved per node !## MH : since it is part of subroutine OxygenStress (via the previous statement \"contains\") !## MH : the output variables are known at this level and not need to be part of the list of arguments integer :: numnod , i real ( 8 ), parameter :: h100 = - 10 0.0d0 real ( 8 ), parameter :: h500 = - 50 0.0d0 real ( 8 ), parameter :: log10h100 = dlog10 ( - h100 ) real ( 8 ), parameter :: log10h500 = dlog10 ( - h500 ) real ( 8 ) theta100 , theta500 , campbell_b , watcon do i = 1 , numnod ! --- get theta at h=-100 cm and at h=-500 cm; for diffusion coef theta100 = watcon ( i , h100 ) theta500 = watcon ( i , h500 ) sat_water_cont = cofgen ( 2 , i ) gfp100 ( i ) = sat_water_cont - theta100 campbell_b = ( log10h500 - log10h100 ) / ( dlog10 ( theta100 ) - dlog10 ( theta500 )) d_soil_term1 ( i ) = 2.0d0 * ( gfp100 ( i ) ** 3 ) + 0.04d0 * gfp100 ( i ) d_soil_term2 ( i ) = 2.0d0 + 3.0d0 / campbell_b !     for use in FUNC !     cofgen(x,i): x = 1...12 !     1 = thetar; 2 = thetas, 3 = Ksatfit; 4 = alpha; 5 = lambda; 6 = n; 7 = m (=1-1/n); !     8 = dummy; 9 = h_enpr; 10 = Ksatexm; 11 = relsatthr; 12 = Ksatthr !     Calculate (sat_water_cont - res_water_cont) * alpha * gen_m * gen_n Capac_term ( i ) = ( cofgen ( 2 , i ) - cofgen ( 1 , i )) * 0.01d0 * cofgen ( 4 , i ) * cofgen ( 6 , i ) * cofgen ( 7 , i ) Nmin1 ( i ) = cofgen ( 6 , i ) - 1.0d0 Mplus1 ( i ) = cofgen ( 7 , i ) + 1.0d0 end do ! --- microbial respiration calculated from organic matter content in actual soil compartment; keep this value fixed shape_factor_microbialr = 0.9d0 ! --- microbial respiration calculated from organic matter content in actual soil compartment; keep this value fixed shape_factor_rootr = 0.9d0 return end subroutine calc_ini_pars subroutine FillOxygenStress1 () !!!!!        if (node.eq.1) ResultsOxStr = -999.d0 !RB20140114 !!!!!          ResultsOxStr(1,node) = node !!!!!          ResultsOxStr(2,node) = z(node)*0.01d0 !!!!!          ResultsOxStr(3,node) = h(node) !!!!!          ResultsOxStr(4,node) = matric_potential !!!!!          ResultsOxStr(5,node) = gas_filled_porosity !!!!!          ResultsOxStr(6,node) = -999.d0 !!!!!          ResultsOxStr(7,node) = -999.d0 !!!!!          ResultsOxStr(8,node) = rwu_factor !!!!!! --- Rpotz0 kg/m3/d !!!!!          ResultsOxStr(9,node)= f_senes * (c_mroot * w_root_z0 *        & !!!!!     &      max_resp_factor) *                                          & !!!!!     &      ( q10_root ** ( (soil_temp - 298.0d0) / 10.0d0 ) ) !!!!!! --- RpotLay kg/m2/d; integrate over function potresp_top_of_compartment*exp(x/shape_factor_rootR); analytical solution !!!!!          ResultsOxStr(10,node)= -1.0d0*((ResultsOxStr(9,node)*         & !!!!!     &      shape_factor_rootR*dexp(-depth/shape_factor_rootr))-      & !!!!!     &      (ResultsOxStr(9,node)*shape_factor_rootr*                   & !!!!!     &      dexp((0.0d0)/shape_factor_rootr))) !!!!!! --- Ractz0 kg/m3/d !!!!!          if (resp_factor.gt.max_resp_factor) then !!!!!            resp_factor = max_resp_factor !!!!!          endif !!!!!          if (resp_factor.lt.1.0d0) then !!!!!            resp_factor = 0.0d0 !!!!!          endif !!!!!          ResultsOxStr(11,node)= f_senes * (c_mroot * w_root_z0 *       & !!!!!     &      resp_factor) *                                              & !!!!!     &      ( q10_root ** ( (soil_temp - 298.0d0 ) / 10.d0 ) ) !!!!!! --- RactLay kg/m2/d; integrate over function actresp_top_of_compartment*exp(x/shape_factor_rootR); analytical solution !!!!!        ResultsOxStr(12,node)= -1.d0*((ResultsOxStr(11,node)*           & !!!!!     &      shape_factor_rootR*dexp(-depth/shape_factor_rootr))-        & !!!!!     &      (ResultsOxStr(11,node)*shape_factor_rootr*                  & !!!!!     &    dexp((0.d0)/shape_factor_rootr))) !!!!!! --- RredLay kg/m2/d !!!!!          ResultsOxStr(13,node)= ResultsOxStr(10,node)-                 & !!!!!     &      ResultsOxStr(12,node) !!!!!! --- RsoilActLay kg/m2/d !!!!!          ResultsOxStr(14,node)= -999.d0 !!!!!! --- dsoil !!!!!          ResultsOxStr(15,node) = -999.d0 !!!!!! --- c_macro !!!!!          ResultsOxStr(16,node)=-999.d0 !kg/m3 !!!!!          ResultsOxStr(17,node)=-999.d0 !!!!!! --- Max resp factor RB20140115 !!!!!          ResultsOxStr(18,node)=max_resp_factor !!!!!! --- wrt from wofost !!!!!          ResultsOxStr(19,node)=-999.d0 !kg/ha return end subroutine FillOxygenStress1 subroutine FillOxygenStress2 () !!!!!      if (node.eq.1) ResultsOxStr = -999.0d0 !RB20140114 !!!!!      ResultsOxStr(1,node) = node !!!!!      ResultsOxStr(2,node) = z(node)*0.01d0 !!!!!      ResultsOxStr(3,node) = h(node) !!!!!      ResultsOxStr(4,node) = matric_potential !!!!!      ResultsOxStr(5,node) = gas_filled_porosity !!!!!      ResultsOxStr(6,node) = w_root_z0 !!!!!      ResultsOxStr(7,node) = waterfilm_thickness !!!!!      ResultsOxStr(8,node) = rwu_factor !!!!!! --- Rpotz0 kg/m3/d !!!!!      ResultsOxStr(9,node)= f_senes * (c_mroot * w_root_z0 *            & !!!!!     &    max_resp_factor) *                                            & !!!!!     &    ( q10_root ** ( (soil_temp - 298.0d0 ) / 10.0d0 ) ) !!!!!! --- RpotLay kg/m2/d; integrate over function potresp_top_of_compartment*exp(x/shape_factor_rootR); analytical solution !!!!!      ResultsOxStr(10,node)= -1.0d0*((ResultsOxStr(9,node)*             & !!!!!     &  shape_factor_rootR*dexp(-depth/shape_factor_rootr))-            & !!!!!     &  (ResultsOxStr(9,node)*shape_factor_rootr*                       & !!!!!     &  dexp((0.0d0)/shape_factor_rootr))) !!!!!! --- Ractz0 kg/m3/d !!!!!      if (resp_factor.gt.max_resp_factor) then !!!!!        resp_factor = max_resp_factor !!!!!      endif !!!!!      if (resp_factor.lt.1.0d0) then !!!!!        resp_factor = 0.0d0 !!!!!      endif !!!!!      ResultsOxStr(11,node)= f_senes * (c_mroot * w_root_z0 *           & !!!!!     &  resp_factor) *                                                  & !!!!!     &  ( q10_root ** ( (soil_temp - 298.0d0 ) / 10.0d0 ) ) !!!!!! --- RactLay kg/m2/d; integrate over function actresp_top_of_compartment*exp(x/shape_factor_rootR); analytical solution !!!!!      ResultsOxStr(12,node)= -1.d0*((ResultsOxStr(11,node)*             & !!!!!     &  shape_factor_rootR*dexp(-depth/shape_factor_rootr))-            & !!!!!     &  (ResultsOxStr(11,node)*shape_factor_rootr*                      & !!!!!     &  dexp((0.d0)/shape_factor_rootr))) !!!!!! --- RredLay kg/m2/d !!!!!      ResultsOxStr(13,node)= ResultsOxStr(10,node)-                     & !!!!!     & ResultsOxStr(12,node) !!!!!! --- RsoilActLay kg/m2/d !!!!!      ResultsOxStr(14,node)= -1.d0*((r_microbial_z0*                    & !!!!!     &   shape_factor_microbialr*dexp(-depth/shape_factor_microbialr))- & !!!!!     &     (r_microbial_z0*shape_factor_microbialr*                     & !!!!!     &      dexp((0.d0)/shape_factor_microbialr))) !!!!!! --- dsoil !!!!!      ResultsOxStr(15,node) = d_soil !!!!!! --- c_macro !!!!!      ResultsOxStr(16,node)=c_macro !kg/m3 !!!!!      ResultsOxStr(17,node)=100.d0*                                     & !!!!!     & c_macro/((0.032*1d5)/(8.314472d0*soil_temp)) !% or kPa !!!!!! --- Max resp factor RB20140115 !!!!!      ResultsOxStr(18,node)=max_resp_factor !!!!!! --- wrt from wofost RBf20140120 !!!!!      if ((croptype(icrop) .eq. 2).or.(croptype(icrop) .eq. 3)) then !!!!!        ResultsOxStr(19,node)=wrt !!!!!      endif return end subroutine FillOxygenStress2 end subroutine OxygenStress ! --- End of main module OxygenStress --------------------------------------------------------------------------------------- subroutine GET_MAX_RESP_FACTOR ( max_resp_factor_gmrf ) use Variables implicit none ! --- Procedure to derive max_resp_factor, ! --- i.e. the ratio between total respiration and maintenance respiration [-] ! --- This ratio is either given in the input file (for a static crop) ! --- or calculated from a series of equations taken from WOFOST (for a dynamic crop) real ( 8 ) afgen real ( 8 ) rmres_gmrf , teff_gmrf , mres_gmrf , asrc_gmrf real ( 8 ) fr_gmrf , fl_gmrf , fs_gmrf , fo_gmrf real ( 8 ) cvf_gmrf real ( 8 ) Froots , Rg_roots , Rm_roots , Max_resp_factor_gmrf ! --- static crop ! --- static crop: max_resp_factor is given in the input file if ( croptype ( icrop ) . eq . 1 ) then max_resp_factor_gmrf = max_resp_factor endif !if (croptype(icrop) .eq. 1) ! --- dynamic crop: max_resp_factor is calculated following the procedure ! --- for the calculation of root maintenance respiration and root growth respiration as ! --- used in WOFOST. ! --- dynamic crop, not grass if ( croptype ( icrop ) . eq . 2 ) then ! --- respiration and partitioning of carbohydrates between growth and ! --- maintenance respiration, based on actual plant state variables rmres_gmrf = ( rmr * wrt + rml * wlv + rms * wst + rmo * wso ) * & & afgen ( rfsetb , 30 , dvs ) !teff_gmrf = q10**((tsoil(10)-25.0d0)/10.0d0) !TEMPORARY!!!! ONLY TO CHECK EFFECT OF USING TSOIL INSTEAD OF TAV; ## MH: /10 = 0.1* teff_gmrf = q10 ** ( 0.1d0 * ( tav - 2 5.0d0 )) mres_gmrf = min ( pgass , rmres_gmrf * teff_gmrf ) ! ## MM 2018-05-07 asrc_gmrf = pgass - mres_gmrf ! ## MM 2018-05-07 ! --- partitioning factors fr_gmrf = afgen ( frtb , 30 , dvs ) !rid for grass, dvs for wofost fl_gmrf = afgen ( fltb , 30 , dvs ) fs_gmrf = afgen ( fstb , 30 , dvs ) fo_gmrf = afgen ( fotb , 30 , dvs ) ! --- dry matter increase, only part in which cvf is calculated cvf_gmrf = 1.0d0 / (( fl_gmrf / cvl + fs_gmrf / cvs + fo_gmrf / cvo ) * & & ( 1.0d0 - fr_gmrf ) + fr_gmrf / cvr ) ! --- cvf: factor used in wofost to calculate the increase in biomass (dmi) from the ! ---  net assimilation of the whole plant (asrc); dmi = cvf*asrc. ! ---  What is left is the growth respiration (i.e. asrc = dmi + growth respiration). ! ---  Therefore, growth respiration of the whole plant = asrc*(1-cvf) ! --- Froots: contribution of the roots to cvf Froots = ( fr_gmrf / cvr ) * cvf_gmrf ! --- Rg_roots: growth respiration roots Rg_roots = Froots * ( 1.0d0 - cvf_gmrf ) * asrc_gmrf ! --- Rm_roots: maintenance respiration roots Rm_roots = min ( Froots * ( 1.0d0 - cvf_gmrf ) * pgass , & & rmr * wrt * afgen ( rfsetb , 30 , dvs ) * teff_gmrf ) ! --- Max_resp_factor: ratio total respiration / maintenance respiration if ( Rm_roots . gt . 0.0d0 ) then Max_resp_factor_gmrf = ( Rg_roots + Rm_roots ) / Rm_roots else Max_resp_factor_gmrf = 1.0d0 endif endif !if (croptype(icrop) .eq. 2) ! --- dynamic crop, grass if ( croptype ( icrop ) . eq . 3 ) then Max_resp_factor_gmrf = 1.0d0 !RB20140317 ! --- skip in case of regrowth, equal to wofost detailed grass ! --- note: daycrop.ge.idregrpot (wofost) --> daycrop.gt.idregrpot, because idregrpot is result of wofost of previous day if ( daycrop . eq . 0 . or . daycrop . gt . idregr ) then ! --- respiration and partitioning of carbohydrates between growth and ! --- maintenance respiration, based on actual plant state variables rmres_gmrf = ( rmr * wrt + rml * wlv + rms * wst ) * afgen ( rfsetb , 30 , rid ) !        teff_gmrf = q10**((tsoil(10)-25.0d0)/10.0d0) !TEMPORARY!!!! ONLY TO CHECK EFFECT OF USING TSOIL INSTEAD OF TAV; ## MH: /10=*0.1 teff_gmrf = q10 ** ( 0.1d0 * ( tav - 2 5.0d0 )) mres_gmrf = min ( pgass , rmres_gmrf * teff_gmrf ) ! ## MM 2018-05-07 asrc_gmrf = pgass - mres_gmrf ! ## MM 2018-05-07 ! --- partitioning factors fr_gmrf = afgen ( frtb , 30 , rid ) !rid for grass, dvs for wofost fl_gmrf = afgen ( fltb , 30 , rid ) fs_gmrf = afgen ( fstb , 30 , rid ) ! --- dry matter increase, only part in which cvf is calculated cvf_gmrf = 1.0d0 / (( fl_gmrf / cvl + fs_gmrf / cvs ) * & & ( 1.0d0 - fr_gmrf ) + fr_gmrf / cvr ) ! --- cvf: factor used in wofost to calculate the increase in biomass (dmi) from the ! ---  net assimilation of the whole plant (asrc); dmi = cvf*asrc. ! ---  What is left is the growth respiration (i.e. asrc = dmi + growth respiration). ! ---  Therefore, growth respiration of the whole plant = asrc*(1-cvf) ! --- Froots: contribution of the roots to cvf Froots = ( fr_gmrf / cvr ) * cvf_gmrf ! --- Rg_roots: growth respiration roots Rg_roots = Froots * ( 1.0d0 - cvf_gmrf ) * asrc_gmrf ! --- Rm_roots: maintenance respiration roots Rm_roots = min ( Froots * ( 1.0d0 - cvf_gmrf ) * pgass , & & rmr * wrt * afgen ( rfsetb , 30 , rid ) * teff_gmrf ) ! --- Max_resp_factor: ratio total respiration / maintenance respiration if ( Rm_roots . gt . 0.d0 ) then Max_resp_factor_gmrf = ( Rg_roots + Rm_roots ) / Rm_roots else Max_resp_factor_gmrf = 1.0d0 endif endif !RB20140317 #skip in case of regrowth endif !if (croptype(icrop) .eq. 3) return end subroutine TEMP_DEPENDENT_PARAMETERS ( d_o2inwater , d_root , & & d_gassfreeair , surface_tension_water , bunsencoeff , soil_temp ) implicit none real ( 8 ) d_o2inwater , d_root , d_gassfreeair real ( 8 ) surface_tension_water , bunsencoeff , soil_temp !     ## MH: d_o2inwater_ref = 24.0d0*3600.0d0*((1.0d-5*1.2d0/(100.0d0*100.0d0)) real ( 8 ), parameter :: d_o2inwater_ref = 1.0d-5 * 1.2d0 / ( 10 0.0d0 * 10 0.0d0 ) real ( 8 ), parameter :: SecsPerDay = 2 4.0d0 * 360 0.0d0 !     ## MH: Tref3 = 1/(293.0d0**3) real ( 8 ), parameter :: Tref3 = 1.0d0 / ( 29 3.0d0 ** 3 ) ! --- Calculate parameters that depend on temperature ! --- diffusion coefficient for oxygen in water [m2/d] Lango et al 1996 !     ## MH: d_o2inwater = SecsPerDay * ( d_o2inwater_ref * dexp ( 0.026d0 * ( soil_temp - 27 3.0d0 ))) ! --- diffusion coefficient for oxygen in root tissue [m2/d] ! --- scaled to d_o2inwater, according the value given by ! --- van noordwijk & de willigen 1987 at 293 k d_root = 0.4d0 * d_o2inwater ! --- diffusion coefficient for oxygen in free air [m2/d] ! --- hirschfelder et al 1964 molecular theory of gases and liquids !     ## MH: Tref3 = 1/(293.0d0**3) d_gassfreeair = 1.74528d0 * ( soil_temp ** 3 ) * Tref3 ! --- surface tension of water [n/m] eotvos rule surface_tension_water = 0.07275d0 * & & ( 1.0d0 - 0.002d0 * ( soil_temp - 29 1.0d0 ) ) ! --- bunsen solubility coeff for oxygen Lango et al 1996 bunsencoeff = & !## MH     &         (1413.d0*(exp(-144.397d0+7775.18d0*(soil_temp**(-1.d0))  & & ( 141 3.d0 * ( dexp ( - 14 4.397d0 + 777 5.18d0 / soil_temp & & + 1 8.3977d0 * dlog ( soil_temp ) + 0.0094437d0 * soil_temp ))) & & * 27 3.15d0 / soil_temp return end real ( 8 ) function FUNC ( x , Capac_term , Nmin1 , Mplus1 , alpha , gen_n , & & surface_tension_water ) implicit none real ( 8 ) x real ( 8 ) Capac_term , Nmin1 , Mplus1 real ( 8 ) alpha , gen_n , surface_tension_water real ( 8 ) pi parameter ( pi = 3.1415926535897932d0 ) real ( 8 ), parameter :: pi4 = 4.0d0 * pi ! ## MH real ( 8 ) :: ax , axn ! ## MH ! --- function needed for calculation of length density of gas filled pores in ! ---   subroutine 'water film thickness' ax = alpha * x axn = ax ** gen_n func = Capac_term * ax ** Nmin1 * ( ( 1.d0 + axn ) ** ( - Mplus1 ) ) / & & ( pi4 * surface_tension_water ** 2 / x ** 2 ) !!!!! func= -(( -(sat_water_cont - res_water_cont) * alpha *            & !!!!!&      ( (ax)**(gen_n - 1.d0) ) *                                  & !!!!!&      ( ( 1.d0 + axn )**(gen_m - 1.d0) )*                         & !!!!!&      gen_m*gen_n ) /                                             & !!!!!&      (((( axn ) + 1.d0 )**gen_m)**2) ) /                         & !!!!!&      (pi4*(((surface_tension_water**2)/(x**2)))) !!! func= -( -(sat_water_cont - res_water_cont) * alpha *            & !!!&      ( (ax)**(gen_n - 1.d0) ) *                                  & !!!&      ( ( 1.d0 + axn )**(-gen_m - 1.d0) )*                        & !!!&      gen_m*gen_n ) /                                             & !!!&      (pi4*(((surface_tension_water**2)/(x**2)))) return end real ( 8 ) function FUNCtab ( x , diff_water_cap , surface_tension_water ) implicit none real ( 8 ) x real ( 8 ) diff_water_cap , surface_tension_water real ( 8 ) pi parameter ( pi = 3.1415926535897932d0 ) real ( 8 ), parameter :: pi4 = 4.0d0 * pi ! ## MH ! --- function needed for calculation of length density of gas filled pores in ! ---   subroutine 'water film thickness' functab = diff_water_cap / ( pi4 * ( surface_tension_water ** 2 ) / ( x ** 2 )) return end !## MH: Romberg could be a better (=faster) method; ask Ruud if he considered this subroutine TRAPZD ( a , b , s , n , Capac_term , Nmin1 , Mplus1 , alpha , gen_n , & & surface_tension_water , glit ) implicit none real ( 8 ) FUNC real ( 8 ) a , b , s integer n ! --- procedure from numerical recipes. calculate integral numerically ! --- Needed for procedure 'water film thickness' ! --- programs calling trapzd must provide a function ! --- func(x:real(8)):real(8)which is to be integrated. they must ! --- also define the variable ! --- var glit: integer; ! --- in the main routine. *) !RB20140312 sum replaced by mysum integer j , glit real ( 8 ) x , tnm , mysum , del real ( 8 ) Capac_term , Nmin1 , Mplus1 real ( 8 ) alpha , gen_n , surface_tension_water ! ---  initialize j j = 0 if ( n . eq . 1 ) then s = 0.5d0 * ( b - a ) * ( func ( a , Capac_term , Nmin1 , Mplus1 , alpha , gen_n , & & surface_tension_water ) & & + func ( b , Capac_term , Nmin1 , Mplus1 , alpha , gen_n , & & surface_tension_water )) glit = 1 else tnm = dble ( glit ) del = ( b - a ) / tnm x = a + 0.5d0 * del mysum = 0.0d0 do while ( j . lt . glit ) mysum = mysum + func ( x , Capac_term , Nmin1 , Mplus1 , alpha , gen_n , & & surface_tension_water ) x = x + del j = j + 1 enddo s = 0.5d0 * ( s + ( b - a ) * mysum / tnm ) glit = 2 * glit endif return end subroutine TRAPZDtab ( a , b , s , n , diff_water_cap , & & surface_tension_water , glit ) implicit none real ( 8 ) functab real ( 8 ) a , b , s integer n ! --- procedure from numerical recipes. calculate integral numerically ! --- Needed for procedure 'water film thickness' ! --- programs calling trapzd must provide a function ! --- func(x:real(8)):real(8)which is to be integrated. they must ! --- also define the variable ! --- var glit: integer; ! --- in the main routine. *) !RB20140312 sum replaced by mysum integer j , glit real ( 8 ) x , tnm , mysum , del real ( 8 ) diff_water_cap , surface_tension_water ! ---  initialize j j = 0 if ( n . eq . 1 ) then s = 0.5d0 * ( b - a ) * ( functab ( a , diff_water_cap , & & surface_tension_water ) & & + functab ( b , diff_water_cap , & & surface_tension_water )) glit = 1 else tnm = dble ( glit ) del = ( b - a ) / tnm x = a + 0.5d0 * del mysum = 0.0d0 do while ( j . lt . glit ) mysum = mysum + functab ( x , diff_water_cap , & & surface_tension_water ) x = x + del j = j + 1 enddo s = 0.5d0 * ( s + ( b - a ) * mysum / tnm ) glit = 2 * glit endif return end subroutine waterfilmthickness ( waterfilm_thickness , & & matric_potential , Capac_term , Nmin1 , Mplus1 , & & alpha , gen_n , surface_tension_water , glit , & & soilphystab , diff_water_cap_actual , numrec_tab ) ! --- calculate water film thickness. method according to simojoki 2000 use Variables use doln implicit none real ( 8 ) waterfilm_thickness , matric_potential real ( 8 ) alpha , gen_n , surface_tension_water , Capac_term , Nmin1 , Mplus1 real ( 8 ) soilphystab ( 7 , matab ) real ( 8 ) diff_water_cap_actual real ( 8 ) lowlim , upplim , diff_water_cap , htab real ( 8 ) length_density_gas_pores_sub integer glit integer i , ii , numrec_tab real ( 8 ) new , old , s real ( 8 ) length_density_gas_pores logical , parameter :: flUseQromb = . true . !## MH: (use Romberg integration; else use orginal trapezoidal integration) save s real ( 8 ) pi parameter ( pi = 3.1415926535897932d0 ) !     Extremely dry; to prevent problems in integration below (observed for coarse sand) we set waterfilm_thickness to som low value !        This will ensure no oxygen related stress (?) if ( matric_potential > 1.0d7 ) then waterfilm_thickness = 1.0d-8 return end if if ( swsophy . eq . 0 ) then ! --- calculate length density air filled (gas) pores. [number per m2] ! --- subroutine trapdz is used to solve the integral defined in ! --- function 'func'. i = 1 if ( flUseQromb ) then call QROMBD ( 1.d-10 , matric_potential , s , Capac_term , & & Nmin1 , Mplus1 , alpha , gen_n , surface_tension_water , glit ) else call TRAPZD ( 1.d-10 , matric_potential , s , i , Capac_term , & & Nmin1 , Mplus1 , alpha , gen_n , surface_tension_water , glit ) end if new = s old = new + new do while ( dabs ( new - old ) . gt . 0.00001d0 * new ) i = i + 1 if ( flUseQromb ) then call QROMBD ( 1.d-10 , matric_potential , s , Capac_term , & & Nmin1 , Mplus1 , alpha , gen_n , surface_tension_water , glit ) else call TRAPZD ( 1.d-10 , matric_potential , s , i , Capac_term , & & Nmin1 , Mplus1 , alpha , gen_n , surface_tension_water , glit ) end if old = new new = s enddo ! --- result from trapzd and func: length_density_gas_pores = new ! --- calculated water film thickness [m] waterfilm_thickness = 2.d0 * & & ( ( dsqrt ( 1.0d0 / ( pi * length_density_gas_pores ) ) ) & ! ## MH: replaced ()**0.5 by dsqrt() & - 2.0d0 * surface_tension_water / matric_potential ) endif !!!!sptab(1,node,ii) = soilphystab(1,ii) if ( swsophy . eq . 1 ) then ii = numrec_tab !34  !run over points in soil hydraulic table ! --- lower value of matric potential for integration interval lowlim = 0.000001d0 !-100*soilphystab(1,ii) !initial value should be zero !RB20140725, very close to zero, otherwise/0 in functab ! --- upper value of matric potential for integration interval if ( do_ln_trans ) then upplim = - 10 0.d0 * 0.5d0 * ( - ( dexp ( - soilphystab ( 1 , ii )) - 1.0d0 ) - ( dexp ( - soilphystab ( 1 , ii - 1 )) - 1.0d0 )) !middle of points 1 and 2 else upplim = - 10 0.d0 * 0.5d0 * ( soilphystab ( 1 , ii ) + soilphystab ( 1 , ii - 1 )) !middle of points 1 and 2 end if upplim = MIN ( upplim , matric_potential ) !upplim can be higher than matpot ! --- initialize length density gas filled pores length_density_gas_pores = 0.0d0 !initial value ! --- start loop, i.e. run over full integration interval; ! --- in each loop, the length density of gas filled pores of that interval is calculated; ! --- The sum of all loops gives the total length density. ! --- The integration interval runs from 0 to the matric potential at the actual node do while (( upplim . lt . matric_potential ) . and . ( ii . gt . 2 )) !adjusted RB20150714 ii.gt.2 added if ( do_ln_trans ) then htab = - ( dexp ( - soilphystab ( 1 , ii )) - 1.0d0 ) diff_water_cap = 0.01d0 * soilphystab ( 4 , ii ) / ( - htab + 1.0d0 ) !at matric potential centre of lowlim and upplim, except for first point else diff_water_cap = 0.01d0 * soilphystab ( 4 , ii ) !at matric potential centre of lowlim and upplim, except for first point end if if ( flUseQromb ) then call QROMBDtab ( lowlim , upplim , s , diff_water_cap , & !n=1 as integral is over a linear function, i.e. convergence is reached after one step & surface_tension_water , glit ) else call TRAPZDtab ( lowlim , upplim , s , 1 , diff_water_cap , & !n=1 as integral is over a linear function, i.e. convergence is reached after one step & surface_tension_water , glit ) end if length_density_gas_pores_sub = s length_density_gas_pores = length_density_gas_pores + & & length_density_gas_pores_sub ii = ii - 1 lowlim = upplim !##MH            upplim=-100.d0*0.5d0*(soilphystab(1,ii)+soilphystab(1,ii-1)) if ( do_ln_trans ) then upplim = - 10 0.d0 * 0.5d0 * ( - ( dexp ( - soilphystab ( 1 , ii )) - 1.0d0 ) - ( dexp ( - soilphystab ( 1 , ii - 1 )) - 1.0d0 )) !middle of points 1 and 2 else upplim = - 10 0.d0 * 0.5d0 * ( soilphystab ( 1 , ii ) + soilphystab ( 1 , ii - 1 )) !middle of points 1 and 2 end if enddo ! --- in the last step (upplim >= matric_potential), always use the differential water capacity corresponding to the actual matric_potential of the node diff_water_cap = diff_water_cap_actual upplim = MIN ( upplim , matric_potential ) if ( flUseQromb ) then call QROMBDtab ( lowlim , upplim , s , diff_water_cap , & !n=1 as integral is over a linear function, i.e. convergence is reached after one step & surface_tension_water , glit ) else call TRAPZDtab ( lowlim , upplim , s , 1 , diff_water_cap , & ! n=1 as integral is over a linear function, i.e. convergence is reached after one step & surface_tension_water , glit ) end if length_density_gas_pores_sub = s length_density_gas_pores = length_density_gas_pores + & & length_density_gas_pores_sub ! --- calculated water film thickness [m] waterfilm_thickness = 2.0d0 * & & ( ( dsqrt ( 1.d0 / ( pi * length_density_gas_pores ) ) ) & ! ## MH: replaced ()**0.5 by dsqrt() & - 2.d0 * surface_tension_water / matric_potential ) endif !ResultsOxStr(7,node) = waterfilm_thickness !RB20140115 return end subroutine microbial_resp ( r_microbial_z0 , soil_temp , perc_org_mat , & & soil_density , percentage_sand , matric_potential , & & specific_resp_humus , q10_microbial ) ! --- Calculate microbial respiration rate, based on available amount of ! --- organic matter, soil moisture and temperature implicit none real ( 8 ) r_microbial_z0 , soil_temp , perc_org_mat real ( 8 ) soil_density , percentage_sand , matric_potential real ( 8 ) specific_resp_humus , q10_microbial real ( 8 ) f_moisture_humus , t_humus , carbon_humuspools real ( 8 ) saturated_matric_potential !     ## MH : define constants real ( 8 ), parameter :: h1 = 2500 0.0d0 real ( 8 ), parameter :: h2 = 76250 0.0d0 real ( 8 ), parameter :: h3 = 150000 0.0d0 real ( 8 ), parameter :: log10h1 = dlog10 ( h1 ) real ( 8 ), parameter :: log10h2 = dlog10 ( h2 ) real ( 8 ), parameter :: log10h3 = dlog10 ( h3 ) real ( 8 ), parameter :: log10h3h2 = log10h3 - log10h2 !     ## MH: end ! --- humus temperature [K] t_humus = soil_temp ! --- available amount of organic carbon [kg/m3]            ## MH: /100 = *0.01 carbon_humuspools = 0.48d0 * ( 0.01d0 * perc_org_mat ) * soil_density ! --- saturated matric potential [pa] calculated according to cosby et al. 1984 ! --- * 100: cm -> pa saturated_matric_potential = ( 1 0.d0 ** ( - 0.0131d0 * percentage_sand + & & 1.88d0 )) * 10 0.0d0 ! --- reduction function for soil moisture: if ( matric_potential . lt . saturated_matric_potential ) then f_moisture_humus = 0.5d0 endif if (( matric_potential . ge . saturated_matric_potential ) & & . and . ( matric_potential . lt . h1 )) then f_moisture_humus = 1.d0 - 0.5d0 * & & (( log10h1 - dlog10 ( matric_potential )) / & & ( log10h1 - & & dlog10 ( saturated_matric_potential ) ) ) endif if (( matric_potential . ge . h1 ) & & . and . ( matric_potential . le . h2 )) then f_moisture_humus = 1.0d0 endif if (( matric_potential . gt . h2 ) & & . and . ( matric_potential . le . h3 )) then f_moisture_humus = 1.d0 - & & (( dlog10 ( matric_potential ) - log10h2 ) / & & ( log10h3h2 ) ) endif if ( matric_potential . gt . h3 ) then f_moisture_humus = 0.0d0 endif ! --- microbial respiration rate at soil surface [kg/m3/d] r_microbial_z0 = specific_resp_humus * carbon_humuspools * & & ( q10_microbial ** ( 0.1d0 * ( t_humus - 29 8.d0 ) ) ) & & * f_moisture_humus return end subroutine MICRO ( c_mroot , w_root , f_senes , q10_root , & & soil_temp , sat_water_cont , gas_filled_porosity , & & d_o2inwater , d_root , perc_org_mat , soil_density , & & specific_resp_humus , q10_microbial , depth , & & shape_factor_microbialr , root_radius , & & waterfilm_thickness , bunsencoeff , & & c_min_micro , resp_factor ) ! --- calculate minimum oxygen concentration in the gas phase of the soil ! --- that is needed to provide all cells within a plant root with a ! --- sufficient amount of oxygen.                                                                     *) implicit none real ( 8 ) c_min_micro , c_mroot , w_root , f_senes , q10_root , soil_temp real ( 8 ) sat_water_cont , gas_filled_porosity real ( 8 ) d_o2inwater , d_root , perc_org_mat , soil_density real ( 8 ) specific_resp_humus , q10_microbial , depth real ( 8 ) shape_factor_microbialr , root_radius real ( 8 ) waterfilm_thickness , bunsencoeff real ( 8 ) resp_factor real ( 8 ) r_mref , r_mroot , waterfilm_porosity , d_waterfilm , lambda real ( 8 ) r_waterfilm_lengthroot , alpha_alpha real ( 8 ) f_moisture_humus , t_humus , carbon_humuspools real ( 8 ) c_min_micro_interphase real ( 8 ) r_microbial_volumetric_wf , r_microbial_z0_wf real ( 8 ) pi parameter ( pi = 3.1415926535897932d0 ) real ( 8 ), parameter :: FourThird = 4.0d0 / 3.0d0 ! ## MH ! --- calc respiration per unit length of root [kg/m/d] r_mref = c_mroot * w_root * resp_factor r_mroot = f_senes * r_mref * & & ( q10_root ** ( 0.1d0 * ( soil_temp - 29 8.d0 ) ) ) ! --- calc porosity of water film [-] waterfilm_porosity = ( sat_water_cont - gas_filled_porosity ) / & & ( 1.0d0 - gas_filled_porosity ) waterfilm_porosity = max ( 0.075d0 , waterfilm_porosity ) !RB20180507, set minimum value for very dry conditions ! --- calc diffusion coeff of water film [m2/d] d_waterfilm = d_o2inwater * ( waterfilm_porosity ** FourThird ) ! --- calc ratio of d_root and d_waterfilm, input for c_min_micro_interphase lambda = d_root / d_waterfilm ! --- start microbial respiration rate in water film ! --- temperature humus [k] t_humus = soil_temp ! --- amount of carbon in humus [kg/m3] carbon_humuspools = 0.48d0 * ( 0.01d0 * perc_org_mat ) * soil_density ! --- reduction factor for moisture [-] (saturation) f_moisture_humus = 0.5d0 ! --- microbial respiration rate at soil surface [kg/m3/d] r_microbial_z0_wf = specific_resp_humus * carbon_humuspools * & & ( q10_microbial ** ( 0.1d0 * ( t_humus - 29 8.d0 ) ) ) * & & f_moisture_humus ! --- volumetric microbial resp rate at depth z [kg/m3/d] r_microbial_volumetric_wf = r_microbial_z0_wf * & & dexp ( - depth / shape_factor_microbialr ) ! --- respiration rate in water film per unit length of root [kg/m/d] r_waterfilm_lengthroot = pi * & & ( ( root_radius + waterfilm_thickness ) ** 2 - & & root_radius ** 2 ) * r_microbial_volumetric_wf ! --- end microbial respiration rate in water film*) ! --- calculation procedure following de willigen & van noordwijk 1983 ! --- p.220-221 ! --- ratio of rhizosphere respiration to total respiration [-] alpha_alpha = r_waterfilm_lengthroot / & & ( r_waterfilm_lengthroot + r_mroot ) ! --- volumetric respiration rate of the root + rhizosphere, but attributed ! ---   to the root (following de willigen & van noordwijk 1983) [kg/m3/d] c_min_micro_interphase = (( r_waterfilm_lengthroot + r_mroot ) / & & ( 2.d0 * pi * d_root )) * & & ( 0.5d0 + ( ( lambda - 1.d0 ) * alpha_alpha / 2.d0 ) + & & lambda * dlog ( 1.d0 + waterfilm_thickness / root_radius ) - & & ( lambda * alpha_alpha * & & ( 1.d0 + waterfilm_thickness / root_radius ) ** 2 ) * & & dlog ( 1.d0 + waterfilm_thickness / root_radius ) / & & ( ( waterfilm_thickness / root_radius ) * & & ( 2.d0 + waterfilm_thickness / root_radius ) ) ) c_min_micro = c_min_micro_interphase / bunsencoeff ! --- end calculation procedure following de willigen & van noordwijk 1983*) return end subroutine MACRO ( c_macro , depth , resp_factor , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctop , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) ! --- calculate oxygen concentration in the soil at a specific depth with respect ! --- to the soil surface. diffusion from atmosphere into soil is considered, ! --- including microbial and root respiration. implicit none real ( 8 ) c_macro , depth , resp_factor real ( 8 ) c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctop real ( 8 ) shape_factor_microbialr , shape_factor_rootr , r_microbial_z0 real ( 8 ) dum , r_mref_z0 , r_mroot_z0 , d_soil , l , lnew , lnew_initial , fi , & & fi_a integer counterMacro , counterMacroSub character ( len = 200 ) error_messag ! --- reference respiration at soil surface per unit volume of roots [kg/m3] *) r_mref_z0 = c_mroot * w_root_z0 * resp_factor ! --- respiration at soil surface per unit volume of roots [kg/m3] r_mroot_z0 = f_senes * r_mref_z0 * & & ( q10_root ** ( 0.1d0 * ( soil_temp - 29 8.d0 ) ) ) ! --- calculate oxygen concentration at certain depth (c_macro [kg/m3] ! --- in the soil. method according to cook 1995 ! --- calculate criterium (dum) to switch to specific equation (if then else) dum = (( shape_factor_microbialr ** 2 ) * r_microbial_z0 / d_soil ) + & & ( ( shape_factor_rootr ** 2 ) * r_mroot_z0 / d_soil ) ! --- as z goes to infinity, the oxygen concentration asymptotically approaches ! ---    a constant non-zero value if ( dum . lt . ctop ) then c_macro = ctop - & & ( ( shape_factor_microbialr ** 2 ) * r_microbial_z0 / d_soil ) * & & ( 1.d0 - dexp ( - depth / shape_factor_microbialr ) ) - & & ( ( shape_factor_rootr ** 2 ) * r_mroot_z0 / d_soil ) * & & ( 1.d0 - dexp ( - depth / shape_factor_rootr ) ) ! --- at z = l the oxygen concentration goes to zero. find l through ! ---    newton-raphson method else counterMacro = 0 counterMacroSub = 0 lnew_initial = 0.1d0 !initialize fi = 1.d0 !initialize fi_a = 1.d0 !initialize lnew = lnew_initial do while (( dabs ( fi ). gt . 1.d-8 ) . AND . & & ( dabs ( fi_a ). gt . 0.d0 ) . AND . & & ( lnew . gt . 1.d-4 )) counterMacro = counterMacro + 1 counterMacroSub = counterMacroSub + 1 l = lnew fi = ctop - & & (( shape_factor_microbialr ** 2 ) * r_microbial_z0 / d_soil ) * & & ( 1.d0 - ( l / shape_factor_microbialr ) * & & dexp ( - l / shape_factor_microbialr ) - & & dexp ( - l / shape_factor_microbialr ) ) - & & ( ( shape_factor_rootr ** 2 ) * r_mroot_z0 / d_soil ) * & & ( 1.d0 - ( l / shape_factor_rootr ) * & & dexp ( - l / shape_factor_rootr ) - & & dexp ( - l / shape_factor_rootr ) ) ! --- derivative of fi to l fi_a = - r_microbial_z0 / d_soil * l * & & dexp ( - l / shape_factor_microbialr ) - & & r_mroot_z0 / d_soil * l * dexp ( - l / shape_factor_rootr ) if ( dabs ( fi_a ) . gt . 0.d0 ) then lnew = dabs ( l - ( fi / fi_a )) endif ! --- for convergence --> depends on initial value of lnew if ( lnew . gt . 1.d3 & & . or . & & counterMacroSub . gt . 100 ) then !restart do while loop with new lnew_initial value lnew_initial = lnew_initial + 0.1d0 lnew = lnew_initial counterMacroSub = 0 endif ! ---       fatal error if too many iterations --> if ( counterMacro . gt . 1.d6 ) then error_messag = '1 Too much iterations for macroscopic ' & & // ' oxygen diffusion.' !D              call warn ('rootextraction',error_messag,logf,swscre) call fatalerr ( 'rootextraction' , error_messag ) endif enddo if ( depth . lt . l ) then c_macro = ctop - & & (( shape_factor_microbialr ** 2 ) * r_microbial_z0 / d_soil ) * & & ( 1.d0 - ( depth / shape_factor_microbialr ) * & & dexp ( - l / shape_factor_microbialr ) - & & dexp ( - depth / shape_factor_microbialr ) ) - & & ( ( shape_factor_rootr ** 2 ) * r_mroot_z0 / d_soil ) * & & ( 1.d0 - ( depth / shape_factor_rootr ) * & & dexp ( - l / shape_factor_rootr ) - & & dexp ( - depth / shape_factor_rootr ) ) else c_macro = 0.0d0 endif endif return end real ( 8 ) function SOLVE ( xi , accuracy ) use O2_pars implicit none real ( 8 ) xiplus1 , ximin1 real ( 8 ) delta real ( 8 ) xi , accuracy real ( 8 ) xx , fxi , xiplusdelta , ximindelta , fxiplusdelta , fximindelta , & & dfxi integer counterSolve character ( len = 200 ) error_messag !      logical, parameter :: UseZBREND = .false. logical , parameter :: UseZBREND = . true . real ( 8 ) :: a , b , Dif_a , Dif_b , ZBREND , myfunc external :: myfunc if ( UseZBREND ) then ! ## MH: start a = 0.0d0 ! 1.0d-6 Dif_a = myfunc ( a ) b = max_resp_factor Dif_b = myfunc ( b ) if ( Dif_a * Dif_b < 0.0d0 ) then SOLVE = ZBREND ( myFUNC , a , b , Dif_a , Dif_b , accuracy ) return else ! same sign if ( Dif_a > 0.0d0 ) then if ( Dif_b < Dif_a ) then xx = max_resp_factor else xx = 0.0d0 end if else if ( Dif_b < Dif_a ) then xx = 0.0d0 else xx = max_resp_factor end if end if call MACRO ( c_macro , depth , xx , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) SOLVE = xx return end if return ! ## MH: end else !## MH: (not use ZBREND; i.e. use original Newton-Raphson approach) ! --- iterative procedure to find the RESPIRATION FACTOR for which holds !RB20131106 ! --- that c_macro = c_micro. reference value = c_micro ! --- Newton-Raphson method ! --- speed up simulations: cut of if ctop = 0 and if waterfilm_thickness is extremely high (due to very low gas filled porosity)     !RB20140826 if ( dabs ( ctopnode ) . lt . 1.0d-6 . OR . & & waterfilm_thickness . gt . 1.d0 ) then xx = 0.d0 C_macro = 0.0d0 SOLVE = xx return endif delta = 1.d-8 fxi = 10 0.d0 counterSolve = 1 do while ( fxi . gt . accuracy ) call MICRO ( c_mroot , w_root , f_senes , q10_root , soil_temp , & & sat_water_cont , gas_filled_porosity , & & d_o2inwater , d_root , perc_org_mat , soil_density , & & specific_resp_humus , q10_microbial , depth , & & shape_factor_microbialr , root_radius , & & waterfilm_thickness , bunsencoeff , & & c_min_micro , xi ) call MACRO ( c_macro , depth , xi , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) fxi = dabs ( C_min_micro - C_macro ) xiplusdelta = xi + delta ximindelta = xi - delta if ( dabs ( xiplusdelta - ximindelta ). lt . 1.d-20 ) then !if (dabs(xiplusdelta-ximindelta).lt.1.d-12) then !if (xiplusdelta .eq. ximindelta) then xiplusdelta = xi + 1.d-6 ximindelta = xi - 1.d-6 endif call MICRO ( c_mroot , w_root , f_senes , q10_root , soil_temp , & & sat_water_cont , gas_filled_porosity , & & d_o2inwater , d_root , perc_org_mat , soil_density , & & specific_resp_humus , q10_microbial , depth , & & shape_factor_microbialr , root_radius , & & waterfilm_thickness , bunsencoeff , & & c_min_micro , xiplusdelta ) call MACRO ( c_macro , depth , xiplusdelta , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) fxiplusdelta = dabs ( C_min_micro - C_macro ) call MICRO ( c_mroot , w_root , f_senes , q10_root , soil_temp , & & sat_water_cont , gas_filled_porosity , & & d_o2inwater , d_root , perc_org_mat , soil_density , & & specific_resp_humus , q10_microbial , depth , & & shape_factor_microbialr , root_radius , & & waterfilm_thickness , bunsencoeff , & & c_min_micro , ximindelta ) call MACRO ( c_macro , depth , ximindelta , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) fximindelta = dabs ( C_min_micro - C_macro ) dfxi = ( fxiplusdelta - fximindelta ) / ( xiplusdelta - ximindelta ) if ( dabs ( dfxi ) . lt . 1.d-20 ) then !if (dabs(dfxi) .lt. 1.d-15) then !RB20140312 xiplus1 = xi else xiplus1 = max ( 1.0d-8 ,( xi - fxi / dfxi )) !xiplus1 = max(1.0d-6,(xi - fxi/dfxi)) !RB20131106, never lt 0 endif !prevent endless sign change without conversion !RB20140827 if ( mod ( counterSolve , 2 ) > 1.d-12 ) then !if even than store xi ximin1 = xi endif !D      write(*,*) counterSolve,xi,ximin1,xiplus1 !DEBUG if ( dabs ( xiplus1 - ximin1 ) . lt . 1.d-6 ) then !no change in xi value, than take average of both values between which is iterated xx = ( xi + xiplus1 ) * 0.5d0 call MACRO ( c_macro , depth , xx , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) SOLVE = xx return endif ! --- speed up simulations: cut of if RWU_factor will be >1 or <1e-6 (=0) if ( xi . lt . 1.0d-6 . AND . xi . gt . 0.0d0 ) then !RB20131106 greater than 0 is required xx = 0.d0 C_macro = 0.0d0 SOLVE = xx return endif if ( xi . gt . max_resp_factor ) then xx = max_resp_factor call MACRO ( c_macro , depth , xx , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) SOLVE = xx return endif xi = xiplus1 ! ---    error if max iterations reached--> counterSolve = counterSolve + 1 if ( counterSolve . gt . 100 ) then error_messag = '1 Max iterations for solver oxygen' & & // ' stress reached.' xx = xi SOLVE = xx call fatalerr ( 'rootextraction' , error_messag ) return endif enddo xx = xi SOLVE = xx return end if ! (UseZBREND) end function SOLVE ! ---------------------------------------------------------------------- subroutine oxygen_dat ( SwTopSub , NrStaring , OxygenSlope , & & OxygenIntercept ) ! ---------------------------------------------------------------------- !     date               : december 2009 !     purpose            : set parameter values of metafunction for oxygenstress ! ---------------------------------------------------------------------- ! --- global integer SwTopSub , NrStaring real ( 8 ) OxygenSlope ( 6 ), OxygenIntercept ( 6 ) ! --- local integer i real ( 8 ) xtop ( 18 , 6 ), xsub ( 18 , 6 ), ytop ( 18 , 6 ), ysub ( 18 , 6 ) data ( xtop ( 1 , i ), i = 1 , 6 ) & & / 5.07d-03 , 2.40d+02 , - 4.39d+00 , - 6.31d+02 , 1.67d+00 , 9.08d+02 / data ( xtop ( 2 , i ), i = 1 , 6 ) & & / 1.20d-02 , 3.26d+02 , - 8.91d+00 , - 9.29d+02 , 2.49d+00 , 1.64d+03 / data ( xtop ( 3 , i ), i = 1 , 6 ) & & / 1.21d-02 , 3.64d+02 , - 9.09d+00 , - 9.90d+02 , 2.60d+00 , 1.70d+03 / data ( xtop ( 4 , i ), i = 1 , 6 ) & & / 1.67d-02 , 4.42d+02 , - 1.21d+01 , - 1.26d+03 , 3.34d+00 , 2.20d+03 / data ( xtop ( 5 , i ), i = 1 , 6 ) & & / 4.17d-03 , 1.93d+02 , - 3.72d+00 , - 5.28d+02 , 1.44d+00 , 7.77d+02 / data ( xtop ( 6 , i ), i = 1 , 6 ) & & / 2.11d-02 , 5.02d+02 , - 1.51d+01 , - 1.40d+03 , 3.69d+00 , 2.71d+03 / data ( xtop ( 7 , i ), i = 1 , 6 ) & & / 2.86d-02 , 5.57d+02 , - 1.97d+01 , - 1.67d+03 , 4.50d+00 , 3.41d+03 / data ( xtop ( 8 , i ), i = 1 , 6 ) & & / 1.75d-02 , 5.55d+02 , - 1.32d+01 , - 1.34d+03 , 3.31d+00 , 2.48d+03 / data ( xtop ( 9 , i ), i = 1 , 6 ) & & / 2.34d-02 , 6.00d+02 , - 1.70d+01 , - 1.40d+03 , 3.42d+00 , 3.09d+03 / data ( xtop ( 10 , i ), i = 1 , 6 ) & & / 3.12d-02 , 6.62d+02 , - 2.20d+01 , - 1.53d+03 , 3.65d+00 , 3.91d+03 / data ( xtop ( 11 , i ), i = 1 , 6 ) & & / 2.58d-02 , 6.42d+02 , - 1.83d+01 , - 1.61d+03 , 4.00d+00 , 3.26d+03 / data ( xtop ( 12 , i ), i = 1 , 6 ) & & / 2.50d-02 , 6.53d+02 , - 1.79d+01 , - 1.45d+03 , 3.40d+00 , 3.21d+03 / data ( xtop ( 13 , i ), i = 1 , 6 ) & & / 2.53d-02 , 5.97d+02 , - 1.79d+01 , - 1.72d+03 , 4.58d+00 , 3.18d+03 / data ( xtop ( 14 , i ), i = 1 , 6 ) & & / 2.82d-02 , 7.10d+02 , - 2.04d+01 , - 1.54d+03 , 3.56d+00 , 3.71d+03 / data ( xtop ( 15 , i ), i = 1 , 6 ) & & / 2.08d-02 , 4.72d+02 , - 1.46d+01 , - 1.37d+03 , 3.65d+00 , 2.57d+03 / data ( xtop ( 16 , i ), i = 1 , 6 ) & & / 1.99d-02 , 4.80d+02 , - 1.39d+01 , - 1.34d+03 , 3.47d+00 , 2.45d+03 / data ( xtop ( 17 , i ), i = 1 , 6 ) & & / 2.27d-02 , 6.31d+02 , - 1.62d+01 , - 1.58d+03 , 3.91d+00 , 2.91d+03 / data ( xtop ( 18 , i ), i = 1 , 6 ) & & / 2.23d-02 , 6.50d+02 , - 1.60d+01 , - 1.74d+03 , 4.45d+00 , 2.89d+03 / data ( xsub ( 1 , i ), i = 1 , 6 ) & & / 7.21d-04 , 1.76d+02 , - 1.59d+00 , - 4.33d+02 , 1.16d+00 , 4.52d+02 / data ( xsub ( 2 , i ), i = 1 , 6 ) & & / 3.75d-03 , 2.25d+02 , - 3.61d+00 , - 5.96d+02 , 1.59d+00 , 7.91d+02 / data ( xsub ( 3 , i ), i = 1 , 6 ) & & / 7.06d-03 , 2.86d+02 , - 5.91d+00 , - 7.52d+02 , 2.00d+00 , 1.19d+03 / data ( xsub ( 4 , i ), i = 1 , 6 ) & & / 1.29d-02 , 3.74d+02 , - 9.74d+00 , - 1.03d+03 , 2.72d+00 , 1.82d+03 / data ( xsub ( 5 , i ), i = 1 , 6 ) & & / 2.92d-03 , 1.86d+02 , - 3.06d+00 , - 5.07d+02 , 1.39d+00 , 6.85d+02 / data ( xsub ( 6 , i ), i = 1 , 6 ) & & / 3.00d-02 , 5.41d+02 , - 2.06d+01 , - 1.69d+03 , 4.61d+00 , 3.55d+03 / data ( xsub ( 7 , i ), i = 1 , 6 ) & & / 2.76d-02 , 6.63d+02 , - 1.95d+01 , - 1.67d+03 , 4.15d+00 , 3.48d+03 / data ( xsub ( 8 , i ), i = 1 , 6 ) & & / 1.85d-02 , 4.88d+02 , - 1.34d+01 , - 1.34d+03 , 3.50d+00 , 2.43d+03 / data ( xsub ( 9 , i ), i = 1 , 6 ) & & / 2.08d-02 , 5.46d+02 , - 1.50d+01 , - 1.50d+03 , 3.92d+00 , 2.72d+03 / data ( xsub ( 10 , i ), i = 1 , 6 ) & & / 1.85d-02 , 5.94d+02 , - 1.39d+01 , - 1.45d+03 , 3.60d+00 , 2.60d+03 / data ( xsub ( 11 , i ), i = 1 , 6 ) & & / 2.29d-02 , 6.33d+02 , - 1.67d+01 , - 1.65d+03 , 4.21d+00 , 3.05d+03 / data ( xsub ( 12 , i ), i = 1 , 6 ) & & / 2.60d-02 , 5.89d+02 , - 1.83d+01 , - 1.33d+03 , 3.12d+00 , 3.26d+03 / data ( xsub ( 13 , i ), i = 1 , 6 ) & & / 3.36d-02 , 6.27d+02 , - 2.29d+01 , - 1.40d+03 , 3.26d+00 , 3.95d+03 / data ( xsub ( 14 , i ), i = 1 , 6 ) & & / 3.84d-02 , 6.74d+02 , - 2.71d+01 , - 1.40d+03 , 3.21d+00 , 4.83d+03 / data ( xsub ( 15 , i ), i = 1 , 6 ) & & / 2.25d-02 , 6.16d+02 , - 1.66d+01 , - 1.37d+03 , 3.22d+00 , 3.05d+03 / data ( xsub ( 16 , i ), i = 1 , 6 ) & & / 1.88d-02 , 4.75d+02 , - 1.32d+01 , - 1.29d+03 , 3.31d+00 , 2.33d+03 / data ( xsub ( 17 , i ), i = 1 , 6 ) & & / 2.19d-02 , 5.40d+02 , - 1.53d+01 , - 1.50d+03 , 3.87d+00 , 2.70d+03 / data ( xsub ( 18 , i ), i = 1 , 6 ) & & / 1.98d-02 , 5.00d+02 , - 1.41d+01 , - 1.40d+03 , 3.67d+00 , 2.52d+03 / data ( ytop ( 1 , i ), i = 1 , 6 ) & & / 1.89d-04 , - 3.91d-01 , - 8.65d-02 , 2.11d+01 , - 8.61d-02 , 7.12d+00 / data ( ytop ( 2 , i ), i = 1 , 6 ) & & / 5.02d-05 , - 7.56d-02 , - 1.01d-02 , 1.80d+01 , - 7.27d-02 , - 2.81d+00 / data ( ytop ( 3 , i ), i = 1 , 6 ) & & / 5.36d-06 , 3.54d-01 , 1.20d-02 , 1.73d+01 , - 7.09d-02 , - 5.51d+00 / data ( ytop ( 4 , i ), i = 1 , 6 ) & & /- 2.67d-05 , 4.87d-02 , 3.03d-02 , 1.76d+01 , - 7.02d-02 , - 7.90d+00 / data ( ytop ( 5 , i ), i = 1 , 6 ) & & / 2.60d-04 , - 1.74d+00 , - 1.16d-01 , 2.28d+01 , - 8.99d-02 , 9.67d+00 / data ( ytop ( 6 , i ), i = 1 , 6 ) & & /- 1.23d-04 , - 6.11d-02 , 8.42d-02 , 1.66d+01 , - 6.63d-02 , - 1.51d+01 / data ( ytop ( 7 , i ), i = 1 , 6 ) & & /- 1.02d-04 , 8.54d-03 , 7.12d-02 , 1.76d+01 , - 7.06d-02 , - 1.33d+01 / data ( ytop ( 8 , i ), i = 1 , 6 ) & & /- 8.09d-05 , 2.23d-01 , 5.65d-02 , 1.62d+01 , - 6.61d-02 , - 1.08d+01 / data ( ytop ( 9 , i ), i = 1 , 6 ) & & /- 9.68d-05 , 1.56d-01 , 6.56d-02 , 1.67d+01 , - 6.76d-02 , - 1.21d+01 / data ( ytop ( 10 , i ), i = 1 , 6 ) & & /- 1.37d-04 , - 4.78d-02 , 8.94d-02 , 1.81d+01 , - 7.09d-02 , - 1.55d+01 / data ( ytop ( 11 , i ), i = 1 , 6 ) & & /- 1.71d-04 , - 2.25d-01 , 1.08d-01 , 1.68d+01 , - 6.46d-02 , - 1.78d+01 / data ( ytop ( 12 , i ), i = 1 , 6 ) & & /- 1.36d-04 , - 5.72d-01 , 8.92d-02 , 1.02d+01 , - 3.91d-02 , - 1.54d+01 / data ( ytop ( 13 , i ), i = 1 , 6 ) & & /- 1.19d-04 , - 8.68d-03 , 8.28d-02 , 1.77d+01 , - 6.97d-02 , - 1.54d+01 / data ( ytop ( 14 , i ), i = 1 , 6 ) & & /- 9.91d-05 , - 9.32d-01 , 7.13d-02 , 1.35d+01 , - 5.10d-02 , - 1.35d+01 / data ( ytop ( 15 , i ), i = 1 , 6 ) & & /- 7.90d-05 , 2.75d-02 , 5.85d-02 , 1.55d+01 , - 6.20d-02 , - 1.16d+01 / data ( ytop ( 16 , i ), i = 1 , 6 ) & & /- 7.91d-05 , 2.32d-01 , 5.71d-02 , 1.10d+01 , - 4.40d-02 , - 1.12d+01 / data ( ytop ( 17 , i ), i = 1 , 6 ) & & /- 2.21d-04 , - 5.23d-01 , 1.39d-01 , 1.44d+01 , - 5.42d-02 , - 2.27d+01 / data ( ytop ( 18 , i ), i = 1 , 6 ) & & /- 1.16d-04 , - 3.60d-01 , 7.85d-02 , 1.05d+01 , - 3.96d-02 , - 1.41d+01 / data ( ysub ( 1 , i ), i = 1 , 6 ) & & / 4.17d-04 , - 1.41d+00 , - 2.06d-01 , 2.42d+01 , - 9.84d-02 , 2.20d+01 / data ( ysub ( 2 , i ), i = 1 , 6 ) & & / 2.56d-04 , - 4.40d-01 , - 1.22d-01 , 2.19d+01 , - 8.92d-02 , 1.16d+01 / data ( ysub ( 3 , i ), i = 1 , 6 ) & & / 1.93d-04 , - 2.84d-01 , - 8.88d-02 , 1.96d+01 , - 8.08d-02 , 7.68d+00 / data ( ysub ( 4 , i ), i = 1 , 6 ) & & / 5.69d-05 , - 7.44d-02 , - 1.48d-02 , 1.80d+01 , - 7.36d-02 , - 2.01d+00 / data ( ysub ( 5 , i ), i = 1 , 6 ) & & / 5.21d-04 , - 1.81d+00 , - 2.61d-01 , 1.96d+01 , - 7.85d-02 , 3.01d+01 / data ( ysub ( 6 , i ), i = 1 , 6 ) & & /- 1.10d-04 , 6.88d-02 , 7.90d-02 , 1.77d+01 , - 7.11d-02 , - 1.48d+01 / data ( ysub ( 7 , i ), i = 1 , 6 ) & & /- 1.76d-04 , - 3.81d-01 , 1.11d-01 , 1.79d+01 , - 6.90d-02 , - 1.85d+01 / data ( ysub ( 8 , i ), i = 1 , 6 ) & & /- 2.38d-05 , 5.72d-01 , 2.47d-02 , 1.64d+01 , - 6.82d-02 , - 6.50d+00 / data ( ysub ( 9 , i ), i = 1 , 6 ) & & /- 4.68d-05 , 4.19d-01 , 3.84d-02 , 1.74d+01 , - 7.16d-02 , - 8.59d+00 / data ( ysub ( 10 , i ), i = 1 , 6 ) & & /- 1.10d-04 , 1.03d-01 , 7.32d-02 , 1.69d+01 , - 6.77d-02 , - 1.32d+01 / data ( ysub ( 11 , i ), i = 1 , 6 ) & & /- 1.48d-04 , - 3.36d-01 , 9.58d-02 , 1.78d+01 , - 6.94d-02 , - 1.64d+01 / data ( ysub ( 12 , i ), i = 1 , 6 ) & & /- 1.58d-04 , 1.36d-01 , 9.92d-02 , 1.56d+01 , - 6.18d-02 , - 1.65d+01 / data ( ysub ( 13 , i ), i = 1 , 6 ) & & /- 2.69d-04 , - 6.12d-01 , 1.66d-01 , 1.27d+01 , - 4.80d-02 , - 2.65d+01 / data ( ysub ( 14 , i ), i = 1 , 6 ) & & /- 6.34d-05 , - 4.27d-01 , 5.05d-02 , 1.73d+01 , - 6.82d-02 , - 1.06d+01 / data ( ysub ( 15 , i ), i = 1 , 6 ) & & / 3.08d-05 , 5.25d-02 , - 6.04d-03 , 8.44d+00 , - 3.54d-02 , - 2.00d+00 / data ( ysub ( 16 , i ), i = 1 , 6 ) & & /- 6.20d-05 , 3.40d-01 , 4.76d-02 , 9.54d+00 , - 3.85d-02 , - 9.98d+00 / data ( ysub ( 17 , i ), i = 1 , 6 ) & & /- 2.90d-05 , 3.99d-01 , 2.75d-02 , 8.07d+00 , - 3.30d-02 , - 6.73d+00 / data ( ysub ( 18 , i ), i = 1 , 6 ) & & /- 6.76d-05 , 4.41d-01 , 5.01d-02 , 1.50d+01 , - 6.10d-02 , - 1.01d+01 / if ( SwTopSub . eq . 1 ) then do i = 1 , 6 OxygenSlope ( i ) = xtop ( NrStaring , i ) OxygenIntercept ( i ) = ytop ( NrStaring , i ) enddo else do i = 1 , 6 OxygenSlope ( i ) = xsub ( NrStaring , i ) OxygenIntercept ( i ) = ysub ( NrStaring , i ) enddo endif return end ! ---------------------------------------------------------------------- subroutine OxygenReproFunction ( OxygenSlope , OxygenIntercept , & & theta , thetas , tsoil , node , z , dz , rwu_factor ) ! ---------------------------------------------------------------------- !     date               : January 2010 !     purpose            : Calculate oxygen stress according to reproduction function ! ---------------------------------------------------------------------- use variables , only : zbotcp implicit none include 'arrays.fi' ! --- global integer node , i real ( 8 ) OxygenSlope ( 6 ), OxygenIntercept ( 6 ), theta ( macp ), thetas ( macp ) real ( 8 ) tsoil ( macp ), z ( macp ), dz ( macp ) ! --- local real ( 8 ) intercept , slope , sum_porosity real ( 8 ) gas_filled_porosity real ( 8 ) soil_temp , depth_ss , mean_gas_filled_porosity real ( 8 ) rwu_factor gas_filled_porosity = thetas ( node ) - theta ( node ) soil_temp = tsoil ( node ) + 27 3.d0 depth_ss = - z ( node ) * 0.01d0 if ( gas_filled_porosity . lt . 1.d-10 ) then rwu_factor = 0.d0 return endif ! --- mean gas filled porosity sum_porosity = 0.0d0 do i = 1 , node sum_porosity = sum_porosity + & & ( thetas ( i ) - theta ( i )) * dz ( i ) enddo mean_gas_filled_porosity = sum_porosity / ( - zbotcp ( node )) intercept = OxygenIntercept ( 1 ) * soil_temp ** 2 + & & OxygenIntercept ( 2 ) * depth_ss ** 2 + & & OxygenIntercept ( 3 ) * soil_temp + & & OxygenIntercept ( 4 ) * depth_ss + & & OxygenIntercept ( 5 ) * soil_temp * depth_ss + & & OxygenIntercept ( 6 ) slope = OxygenSlope ( 1 ) * soil_temp ** 2 + & & OxygenSlope ( 2 ) * depth_ss ** 2 + & & OxygenSlope ( 3 ) * soil_temp + & & OxygenSlope ( 4 ) * depth_ss + & & OxygenSlope ( 5 ) * soil_temp * depth_ss + & & OxygenSlope ( 6 ) ! --- Calculate the sink term (Root Water Uptake) variable due to oxygen stress. rwu_factor = intercept + slope * mean_gas_filled_porosity if ( rwu_factor . gt . 1.d0 ) then rwu_factor = 1.d0 endif if ( rwu_factor . lt . 0.d0 ) then rwu_factor = 0.d0 endif return end !-----------------------------------------------------------------------* ! From W.H. Press, B.P. Flannery, S.A. Teukolsky and W.T. Vettering,    * ! 1986. Numerical recipes. The art of scientific computing. Cambridge   * ! University Press, Cambridge, 818 pp.                                  * ! Double Precision version                                              * !-----------------------------------------------------------------------* !      SUBROUTINE QROMBD (FUNC,A,B,SS) SUBROUTINE QROMBD ( a , b , ss , Capac_term , Nmin1 , Mplus1 , & & alpha , gen_n , surface_tension_water , glit ) IMPLICIT NONE real ( 8 ) a , b , ss integer glit real ( 8 ) Capac_term , Nmin1 , Mplus1 real ( 8 ) alpha , gen_n , surface_tension_water INTEGER JMAX , JMAXP , K , KM , J , L REAL ( 8 ) EPS , S , H , DSS !      REAL(8)          FUNC PARAMETER ( EPS = 1.D-5 , JMAX = 20 , JMAXP = JMAX + 1 , K = 5 , KM = K - 1 ) !      PARAMETER (EPS=1.D-10,JMAX=100,JMAXP=JMAX+1,K=5,KM=K-1) DIMENSION S ( JMAXP ), H ( JMAXP ) !      EXTERNAL  FUNC H ( 1 ) = 1.D0 ; s ( 1 ) = 0.0d0 DO 11 J = 1 , JMAX !        CALL TRAPZDD (FUNC,A,B,S(J),J) CALL TRAPZD ( a , b , s ( j ), j , Capac_term , Nmin1 , Mplus1 , & & alpha , gen_n , surface_tension_water , glit ) IF ( J . GE . K ) THEN L = J - KM !          CALL POLINTD (H(L),S(L),K,0.D0,SS,DSS) CALL POLINTD ( H ( L : J ), S ( L : J ), K , 0.D0 , SS , DSS ) IF ( DABS ( DSS ) . LT . EPS * DABS ( SS )) RETURN END IF S ( J + 1 ) = S ( J ) H ( J + 1 ) = 0.25D0 * H ( J ) 11 CONTINUE !      PAUSE 'Too many steps.' write ( * , * ) 'QROMBD Too many steps.' !read (*,*) END !-----------------------------------------------------------------------* ! From W.H. Press, B.P. Flannery, S.A. Teukolsky and W.T. Vettering,    * ! 1986. Numerical recipes. The art of scientific computing. Cambridge   * ! University Press, Cambridge, 818 pp.                                  * ! Double Precision version                                              * !-----------------------------------------------------------------------* SUBROUTINE QROMBDtab ( a , b , ss , dif_water_cap , surface_tension_water , glit ) IMPLICIT NONE real ( 8 ) a , b , ss integer glit real ( 8 ) dif_water_cap , surface_tension_water INTEGER JMAX , JMAXP , K , KM , J , L REAL ( 8 ) EPS , S , H , DSS !      REAL(8)          FUNC PARAMETER ( EPS = 1.D-5 , JMAX = 100 , JMAXP = JMAX + 1 , K = 5 , KM = K - 1 ) !      PARAMETER (EPS=1.D-10,JMAX=100,JMAXP=JMAX+1,K=5,KM=K-1) DIMENSION S ( JMAXP ), H ( JMAXP ) !      EXTERNAL  FUNC H ( 1 ) = 1.D0 ; s ( 1 ) = 0.0d0 DO 11 J = 1 , JMAX !        CALL TRAPZDD (FUNC,A,B,S(J),J) CALL TRAPZDtab ( a , b , s ( j ), j , dif_water_cap , surface_tension_water , glit ) IF ( J . GE . K ) THEN L = J - KM !          CALL POLINTD (H(L),S(L),K,0.D0,SS,DSS) CALL POLINTD ( H ( L : J ), S ( L : J ), K , 0.D0 , SS , DSS ) IF ( DABS ( DSS ) . LT . EPS * DABS ( SS )) RETURN END IF S ( J + 1 ) = S ( J ) H ( J + 1 ) = 0.25D0 * H ( J ) 11 CONTINUE !      PAUSE 'Too many steps.' write ( * , * ) 'QROMBDtab Too many steps.' read ( * , * ) END !-----------------------------------------------------------------------* ! From W.H. Press, B.P. Flannery, S.A. Teukolsky and W.T. Vettering,    * ! 1986. Numerical recipes. The art of scientific computing. Cambridge   * ! University Press, Cambridge, 818 pp.                                  * ! Double Precision version                                              * !-----------------------------------------------------------------------* SUBROUTINE POLINTD ( XA , YA , N , X , Y , DY ) IMPLICIT NONE INTEGER N , NS , I , M , NMAX REAL ( 8 ) XA , YA , C , D , X , Y , DY , DIF , DIFT , HO , HP , DEN , W PARAMETER ( NMAX = 10 ) DIMENSION XA ( N ), YA ( N ), C ( NMAX ), D ( NMAX ) NS = 1 DIF = DABS ( X - XA ( 1 )) DO 11 I = 1 , N DIFT = DABS ( X - XA ( I )) IF ( DIFT . LT . DIF ) THEN NS = I DIF = DIFT END IF C ( I ) = YA ( I ) D ( I ) = YA ( I ) 11 CONTINUE Y = YA ( NS ) NS = NS - 1 DO 13 M = 1 , N - 1 DO 12 I = 1 , N - M HO = XA ( I ) - X HP = XA ( I + M ) - X W = C ( I + 1 ) - D ( I ) DEN = HO - HP IF ( DEN . EQ . 0.D0 ) then !             PAUSE 'NR_POLINTD: DEN = 0' write ( * , * ) 'NR_POLINTD: DEN = 0' read ( * , * ) end if DEN = W / DEN D ( I ) = HP * DEN C ( I ) = HO * DEN 12 CONTINUE IF ( 2 * NS . LT . N - M ) THEN DY = C ( NS + 1 ) ELSE DY = D ( NS ) NS = NS - 1 END IF Y = Y + DY 13 CONTINUE RETURN END real ( 8 ) function myfunc ( x ) use O2_pars real ( 8 ) :: x call MICRO ( c_mroot , w_root , f_senes , q10_root , soil_temp , & & sat_water_cont , gas_filled_porosity , & & d_o2inwater , d_root , perc_org_mat , soil_density , & & specific_resp_humus , q10_microbial , depth , & & shape_factor_microbialr , root_radius , & & waterfilm_thickness , bunsencoeff , & & c_min_micro , x ) call MACRO ( c_macro , depth , x , & & c_mroot , w_root_z0 , f_senes , q10_root , soil_temp , ctopnode , & & shape_factor_microbialr , shape_factor_rootr , & & r_microbial_z0 , d_soil ) myfunc = c_macro - c_min_micro end function myfunc !     Adapted: initial FA and FB are input DOUBLE PRECISION FUNCTION ZBREND ( FUNC , X1 , X2 , FA , FB , TOL ) IMPLICIT NONE INTEGER ITMAX , ITER DOUBLE PRECISION EPS , X1 , X2 , TOL , A , B , FA , FB , FC , C , D , E , XM , TOL1 , P , Q , R , S DOUBLE PRECISION FUNC !      PARAMETER (ITMAX=100,EPS=3.D-8) PARAMETER ( ITMAX = 100 , EPS = 3.D-16 ) A = X1 B = X2 !      FA=FUNC(A) !      FB=FUNC(B) !      IF (FB*FA.GT.0.D0) PAUSE 'Root must be bracketed for ZBREND.' FC = FB DO 11 ITER = 1 , ITMAX IF ( FB * FC . GT . 0.D0 ) THEN C = A FC = FA D = B - A E = D ENDIF IF ( DABS ( FC ). LT . DABS ( FB )) THEN A = B B = C C = A FA = FB FB = FC FC = FA ENDIF TOL1 = 2.D0 * EPS * DABS ( B ) + 0.5D0 * TOL XM = . 5 D0 * ( C - B ) IF ( DABS ( XM ). LE . TOL1 . OR . FB . EQ . 0.D0 ) THEN ZBREND = B RETURN ENDIF IF ( DABS ( E ). GE . TOL1 . AND . DABS ( FA ). GT . DABS ( FB )) THEN S = FB / FA IF ( A . EQ . C ) THEN P = 2.D0 * XM * S Q = 1.D0 - S ELSE Q = FA / FC R = FB / FC P = S * ( 2.D0 * XM * Q * ( Q - R ) - ( B - A ) * ( R - 1.D0 )) Q = ( Q - 1.D0 ) * ( R - 1.D0 ) * ( S - 1.D0 ) ENDIF IF ( P . GT . 0.D0 ) Q =- Q P = DABS ( P ) IF ( 2.D0 * P . LT . DMIN1 ( 3.D0 * XM * Q - DABS ( TOL1 * Q ), DABS ( E * Q ))) THEN E = D D = P / Q ELSE D = XM E = D ENDIF ELSE D = XM E = D ENDIF A = B FA = FB IF ( DABS ( D ) . GT . TOL1 ) THEN B = B + D ELSE B = B + SIGN ( TOL1 , XM ) ENDIF FB = FUNC ( B ) 11 CONTINUE !      PAUSE 'ZBREND exceeding maximum iterations.' write ( * , * ) 'ZBREND exceeding maximum iterations.' read ( * , * ) ZBREND = B RETURN END","tags":"","loc":"sourcefile/oxygenstress.f90.html"},{"title":"checkmassbal.f90 – API reference SWAP","text":"Source Code ! File VersionID: !   $Id: checkmassbal.f90 341 2017-09-29 18:12:25Z kroes006 $ ! ---------------------------------------------------------------------- subroutine checkmassbal ( flopenfiledev , inqdranew , iqexcmtxdm1cpnew , iqexcmtxdm2cpnew , inqnew , iqoutdrrapcpnew , inqrotnew , ithetabegnew , thetanew ) ! ---------------------------------------------------------------------- !     Date               : 26-jun-2003 !     Purpose            : Checking of mass balance per period OutPer for !                          ANIMO/PEARL output !     Subroutines called : - !     Functions called   : - !     File usage         : outfil ! --------------------------------------------------------------------- use variables , only : DayCum , nrlevs , NumNodNew , IcTopMp , FlMacropore , outfil , pathwork , DZNew , & CritDevMasBal , ievap , igird , igrai , igSnow , inird , inrai , IPondBeg , IQInTopVrtDm1 , IQInTopLatDm1 , IQInTopVrtDm2 , & IQInTopLatDm2 , ISsnowBeg , iruno , irunon , isnrai , iSubl , pond , Ssnow , IWaSrDm1Beg , IWaSrDm2Beg , WaSrDm1 , WaSrDm2 implicit none include 'arrays.fi' ! -   global real ( 8 ) IQExcMtxDm1CpNew ( macp ), IQExcMtxDm2CpNew ( macp ) real ( 8 ) inqdraNew ( Madr , macp ) real ( 8 ) inqNew ( macp + 1 ), IQOutDrRapCpNew ( macp ), inqrotNew ( macp ) real ( 8 ) IThetaBegNew ( MaCp ), thetaNew ( macp ) logical FlOpenFileDev ! -   local integer Dev , Level , getun , ic real ( 8 ) DevMasBalDm1 , DevMasBalDm2 , DevMasBalCmp ( MaCp ) real ( 8 ) DevMasBalPnd , DevMasBalPrf , IQExcMtxDm1 real ( 8 ) IQExcMtxDm2 , IQInTopLatDm , IQInTopPreDm , IQOutDrRap real ( 8 ) Qdra ( MaCp ), QdraPrf , QrotPrf , SrDif real ( 8 ) WaSr ( MaCp ), WaSrBeg ( MaCp ), WaSrPrf , WaSrPrfBeg character ( len = 300 ) filnam logical FlWriteDevCmp ( MaCp ), FlWriteDev , FlWriteDevDm1 logical FlWriteDevDm2 , FlWriteDevPnd , FlWriteDevPrf !     save values of locals save dev ! ---------------------------------------------------------------------- ! --- Checking of mass balances of sub systems per period OutPer FlWriteDev = . false . FlWriteDevPnd = . false . FlWriteDevPrf = . false . do ic = 1 , NumNodNew FlWriteDevCmp ( ic ) = . false . enddo FlWriteDevDm1 = . false . FlWriteDevDm2 = . false . !   - 1) Ponding layer SrDif = IPondBeg - Pond + ISsnowBeg - Ssnow IQInTopPreDm = 0.d0 IQInTopLatDm = 0.d0 if ( FlMacropore . and . IcTopMp . eq . 1 ) then IQInTopPreDm = IQInTopVrtDm1 + IQInTopVrtDm2 IQInTopLatDm = IQInTopLatDm1 + IQInTopLatDm2 endif !     - Deviation mass balance Ponding layer in cm DevMasBalPnd = igrai + igsnow + igird + irunon + inqNew ( 1 ) + SrDif & & - ( igrai - inrai - isnrai + igird - inird + isubl + ievap & & + iruno ) - IQInTopPreDm - IQInTopLatDm !     &             - (igrai-inrai-isnrai + igird-inird + isubl + ievap + iruno) & !     &             - IQInTopPreDm - IQInTopLatDm !     - Check mass balance against criteria if ( abs ( DevMasBalPnd ). gt . CritDevMasBal ) then FlWriteDev = . true . FlWriteDevPnd = . true . endif !   - 2) Total Soil Profile WaSrPrfBeg = 0.d0 WaSrPrf = 0.d0 QrotPrf = 0.d0 QdraPrf = 0.d0 IQExcMtxDm1 = 0.d0 IQExcMtxDm2 = 0.d0 do ic = 1 , numnodnew WaSrPrfBeg = WaSrPrfBeg + dzNew ( ic ) * IThetaBegNew ( ic ) WaSrPrf = WaSrPrf + dzNew ( ic ) * ThetaNew ( ic ) QrotPrf = QrotPrf + inqrotNew ( ic ) do level = 1 , nrlevs QdraPrf = QdraPrf + InqdraNew ( level , ic ) enddo if ( FlMacropore ) then IQExcMtxDm1 = IQExcMtxDm1 + IQExcMtxDm1CpNew ( ic ) IQExcMtxDm2 = IQExcMtxDm2 + IQExcMtxDm2CpNew ( ic ) endif enddo SrDif = WaSrPrfBeg - WaSrPrf !     - Deviation mass balance total Profile in cm DevMasBalPrf = inqNew ( NumNodNew + 1 ) + SrDif + IQExcMtxDm1 + & & IQExcMtxDm2 - ( inqNew ( 1 ) + QrotPrf + QdraPrf ) !     - Check mass balance against criteria if ( abs ( DevMasBalPrf ). gt . CritDevMasBal ) then FlWriteDev = . true . FlWriteDevPrf = . true . endif !   - 3) Individual Soil Compartments do 100 ic = 1 , numnodnew SrDif = 0.d0 Qdra ( ic ) = 0.d0 WaSrBeg ( ic ) = dzNew ( ic ) * IThetaBegNew ( ic ) WaSr ( ic ) = dzNew ( ic ) * ThetaNew ( ic ) SrDif = WaSrBeg ( ic ) - WaSr ( ic ) do level = 1 , nrlevs Qdra ( ic ) = Qdra ( ic ) + inqdraNew ( level , ic ) enddo !     - Deviation mass balance Soil Compartments in cm DevMasBalCmp ( ic ) = inqNew ( ic + 1 ) + SrDif & & - ( inqNew ( ic ) + inqrotNew ( ic ) + Qdra ( ic )) if ( FlMacropore ) DevMasBalCmp ( ic ) = DevMasBalCmp ( ic ) + & & IQExcMtxDm1CpNew ( ic ) + IQExcMtxDm2CpNew ( ic ) !     - Check mass balance against criteria if ( abs ( DevMasBalCmp ( ic )). gt . CritDevMasBal ) then FlWriteDev = . true . FlWriteDevCmp ( ic ) = . true . endif 100 continue !   - 4) Macropore domains Dm1 and Dm2 if ( FlMacropore ) then IQOutDrRap = 0.d0 do ic = 1 , numnodnew IQOutDrRap = IQOutDrRap + IQOutDrRapCpNew ( ic ) enddo !     - Deviation mass balance Macropore Domains in cm SrDif = IWaSrDm1Beg - WaSrDm1 DevMasBalDm1 = IQInTopLatDm1 + SrDif - ( IQExcMtxDm1 + IQOutDrRap ) if ( IcTopMp . eq . 1 ) DevMasBalDm1 = DevMasBalDm1 + IQInTopVrtDm1 SrDif = IWaSrDm2Beg - WaSrDm2 DevMasBalDm2 = IQInTopLatDm2 + SrDif - IQExcMtxDm2 if ( IcTopMp . eq . 1 ) DevMasBalDm2 = DevMasBalDm2 + IQInTopVrtDm2 !     - Check mass balance against criteria if ( abs ( DevMasBalDm1 ). gt . CritDevMasBal ) then FlWriteDev = . true . FlWriteDevDm1 = . true . endif if ( abs ( DevMasBalDm2 ). gt . CritDevMasBal ) then FlWriteDev = . true . FlWriteDevDm2 = . true . endif endif ! ! --- In case of deviations of mass balance open file 'xxxxx.dwb.csv' if ( FlWriteDev . and . . not . FlOpenFileDev ) then filnam = trim ( pathwork ) // trim ( outfil ) // '.dwb' dev = getun ( 20 , 90 ) call fopens ( dev , filnam , 'new' , 'del' ) write ( dev , 1 ) if ( FlMacropore ) write ( dev , 2 ) FlOpenFileDev = . true . endif !   - Write deviations of water balance Top system if ( FlWriteDevPnd ) write ( dev , 3 ) daycum , DevMasBalPnd , & & igrai , igsnow , igird , irunon , isnrai , igrai - inrai , igird - inird ,& & isubl , ievap , iruno , inqNew ( 1 ), Pond , IPondBeg , Ssnow , & & ISsnowBeg , IQInTopPreDm , IQInTopLatDm !   - Write deviations of water balance whole Profile if ( FlWriteDevPrf ) write ( dev , 4 ) daycum , DevMasBalPrf , & & inqNew ( 1 ), inqNew ( NumNodNew + 1 ), QrotPrf , QdraPrf , WaSrPrf , & & WaSrPrfBeg , IQExcMtxDm1 , IQExcMtxDm2 !   - Write deviations of water balance of Individual Soil Compartments do ic = 1 , numnodnew if ( FlWriteDevCmp ( ic )) write ( dev , 5 ) daycum , ic , DevMasBalCmp ( ic ),& & inqNew ( ic ), inqNew ( ic + 1 ), inqrotNew ( ic ), Qdra ( ic ), WaSr ( ic ),& & WaSrBeg ( ic ), IQExcMtxDm1CpNew ( ic ), IQExcMtxDm2CpNew ( ic ) enddo !   - Write deviations of water balance Macropore Domains if ( FlWriteDevDm1 ) write ( dev , 6 ) daycum , DevMasBalDm1 , & & IQInTopVrtDm1 , IQInTopLatDm1 , IQExcMtxDm1 , WaSrDm1 , & & IWaSrDm1Beg , IQOutDrRap if ( FlWriteDevDm2 ) write ( dev , 7 ) daycum , DevMasBalDm2 , & & IQInTopVrtDm2 , IQInTopLatDm2 , IQExcMtxDm2 , WaSrDm2 , & & IWaSrDm2Beg ! 1 format ( ' DEVIATIONS WATERBALANCE for different subsystems: 1. Pon' & & 'd.layer; 2. Whole profile; 3. Compartment; (optional: Macrop.Dom' & & '.: 4. Dom1; 5. Dom2)' , / , & & ' Relevant terms of waterbalance per subsystem' , & & ' (all terms in cm):' , // , & & ' DayCum, 1. PONDLAY., DevMasBalAbs, IgRai, IgSnow, IgIrd, IRunon' & & ', SnowFall,IntcpRai, IntcpIrd, ISubl, IEvap, IRuno, InQTop,   ' , & & 'Pond, IPondBeg, Ssnow, ISsnowBeg, IQInTopPreDm, IQInTopLatDm,' , / ,& & ' , 2. PROFILE, DevMasBalPrf, InQTop, InQBot, QrotPrf, QdraPrf,' , & & ' WaSrPrf, WaSrPrfBeg, InQExcMtxDm1, InQExcMtxDm2' , / , & & ' , 3. COMPno, DevMasBalCmp, InQNew(top), InQNew(bot),' , & & ' InQrotNew, Qdra, WaSr, WaSrBeg, InQExcMtxDm1CpNew,' , & & ' InQExcMtxDm2CpNew' ) 2 format ( ' , 4. MPDOM1, DevMasBalDm1, IQInTopPre/VrtDm1,' , & & ' IQInTopLatDm1, InQExcMtxDm1, WaSrDm1, IWaSrDm1Beg, InQOutDrRap' / & & ' , 5. MPDOM2, DevMasBalDm2, IQInTopPre/VrtDm2, IQInTopLatDm2,    & & InQExcMtxDm2, WaSrDm2, IWaSrDm2Beg' ) 3 format ( i5 , ',' , ' Pondlay. : ' , 18 ( ',' , f12 . 8 )) 4 format ( i5 , ',' , ' Profile : ' , 9 ( ',' , f12 . 8 )) 5 format ( i5 , ',' , ' Comp' , i3 , ': ' , 9 ( ',' , f12 . 8 )) 6 format ( i5 , ',' , ' MpDom1 : ' , 7 ( ',' , f12 . 8 )) 7 format ( i5 , ',' , ' MpDom2 : ' , 6 ( ',' , f12 . 8 )) return end","tags":"","loc":"sourcefile/checkmassbal.f90.html"},{"title":"boundbottom.f90 – API reference SWAP","text":"Source Code ! File VersionID: !   $Id: boundbottom.f90 362 2018-01-08 13:08:33Z kroes006 $ ! ---------------------------------------------------------------------- !> \\brief Determines the soil profile bottom boundary conditions. !! !! This subroutine calculates the boundary conditions at the bottom of a soil profile. !! It handles various cases such as given groundwater level, regional bottom flux, !! seepage or infiltration from/to deep groundwater, zero flux, free drainage, and !! lysimeter with free drainage. !! !! \\date August 2004 / Sept 2005 ! ---------------------------------------------------------------------- subroutine BoundBottom use variables implicit none ! --- local variables integer node , nodnumgwl real ( 8 ) cvalprof , gwlmean , thetabot , twopi , freq real ( 8 ) satnodgwl real ( 8 ) watcon , hconduc , afgen character ( len = 300 ) messag ! --- Constants twopi = 8.0d0 * datan ( 1.0d0 ) freq = twopi / 36 5.0d0 ! ---------------------------------------------------------------------- ! --- interpolation between daily values of given groundwaterlevel if ( swbotb . eq . 1 ) then gwlinp = afgen ( gwltab , mabbc * 2 , t1900 + dt ) endif ! --- regional bottom flux is given if ( abs ( swbotb ) . eq . 2 ) then ! Comment PietG (8-1-08): ! ---   if the moisture content in the soil profile is depleted by !       a combination of inconsistent boundary conditions, and !       the pressure head at the bottom tends to very low values, !       then the choice for swbotb=2 is not appropriate. if ( h ( numnod ). lt . - 1.0d+7 ) then ! oven dry conditions at bottom if ( swbotb . eq . 2 ) then write ( messag , '(a)' ) 'Oven dry conditions in lowest' write ( messag , '(a)' ) 'compartment therefore switched to' write ( messag , '(a)' ) 'free drainage at date ' write ( messag , * ) write ( messag , '(a11)' ) date call warn ( 'BoundBottom' , messag , logf , 0 ) end if swbotb = - 2 else swbotb = 2 end if if ( swbotb . eq . 2 ) then if ( sw2 . eq . 1 ) then ! ---     sine function is used qbot = sinave + sinamp * dcos ( freq * ( t - sinmax )) else ! ---     table is used qbot = afgen ( qbotab , mabbc * 2 , t1900 + dt ) endif end if ! ---   free drainage assumed in case of h(numnod) < -1.0E7 if ( swbotb . eq . - 2 ) qbot = - 1.0d0 * kmean ( numnod + 1 ) endif ! --- seepage or infiltration from/to deep groundwater if ( swbotb . eq . 3 ) then gwlmean = hdrain + shape * ( gwl - hdrain ) ! ---   determine hydraulic head of deep aquifer if ( sw3 . eq . 1 ) then deepgw = aqave + aqamp * dcos ( twopi / aqper * ( t - aqtmax )) else deepgw = afgen ( haqtab , mabbc * 2 , t1900 + dt ) endif ! ---   determine C-value (vertical resistance) in saturated part of modelled profile if ( SwBotb3ResVert . eq . 0 ) then !     -   find number node with groundwater level node = numnod do while ( gwlmean . gt . ztopcp ( node ) . and . node . gt . 1 ) node = node - 1 enddo nodnumgwl = node satnodgwl = gwlmean - zbotcp ( nodnumgwl ) cvalprof = satnodgwl / cofgen ( 3 , nodnumgwl ) do node = nodnumgwl + 1 , numnod cvalprof = cvalprof + dz ( node ) / cofgen ( 3 , node ) enddo elseif ( SwBotb3ResVert . eq . 1 ) then cvalprof = 0.0d0 endif ! qbot = ( deepgw - gwlmean ) / ( rimlay + cvalprof ) ! ---   extra groundwater flux might be added if ( sw4 . eq . 1 ) qbot = qbot + afgen ( qbotab , mabbc * 2 , t1900 + dt ) endif ! --- flux calculated as function of h if ( swbotb . eq . 4 ) then if ( swqhbot . eq . 1 ) then qbot = cofqha * dexp ( cofqhb * dabs ( gwl )) if ( swcofqhc . eq . 1 ) qbot = qbot + cofqhc else if ( swqhbot . eq . 2 ) then qbot = afgen ( qbotab , mabbc * 2 , dabs ( gwl )) endif endif ! --- interpolation between daily values of given pressurehead if ( swbotb . eq . 5 ) then hbot = afgen ( hbotab , mabbc * 2 , t1900 + dt ) thetabot = watcon ( numnod , hbot ) kmean ( numnod + 1 ) = hconduc ( numnod , hbot , thetabot , rfcp ( numnod )) if ( flMacroPore ) then kmean ( numnod + 1 ) = FrArMtrx ( numnod ) * kmean ( numnod + 1 ) endif endif ! --- zero flux at the bottom if ( swbotb . eq . 6 ) qbot = 0.0d0 ! --- free drainage if ( swbotb . eq . 7 ) qbot = - 1.0d0 * kmean ( numnod + 1 ) ! --- lysimeter with free drainage if ( swbotb . eq . 8 ) qbot = 0.0d0 qbot_nonfrozen = qbot return end","tags":"","loc":"sourcefile/boundbottom.f90.html"},{"title":"tridag.f90 – API reference SWAP","text":"Source Code ! File VersionID: !   $Id: tridag.f90 341 2017-09-29 18:12:25Z kroes006 $ ! ---------------------------------------------------------------------- SUBROUTINE TRIDAG ( N , A , B , C , R , U , ierror ) !*********************************************************************** !* Date      : 15/9/99 !* Purpose:    Solves for a vector U a tridiagonal linear set.         * !* References:                                                         * !* Press, W.H., B.P. Flannery, S.A. Teukolsky & W.T. Vetterling, 1989. * !* Numerical Recipes in FORTRAN. Cambridge University Press, New York. * !* pp 40-41                                                            * !*********************************************************************** !* Input:     N -      Number of equations                             * !*            A,B,C -  Coefficients of the matrix                      * !*            R -      known vector                                    * !* Output:    U -      solved vector                                   * !*********************************************************************** implicit none include 'arrays.fi' ! --- global declarations ! --- (i.i) input integer n , ierror real ( 8 ) a ( n ), b ( n ), c ( n ), r ( n ) ! --- output real ( 8 ) u ( n ) ! --- parameters real ( 8 ) small parameter ( small = 0.3d-37 ) ! --- local declarations integer i real ( 8 ) gamma ( macp ), beta character ( len = 200 ) messag ! ---------------------------------------------------------------------- ierror = 0 ! --- (1) if b(1)=0 then rewrite the equations as a set of order n-1 !     to eliminate u(2) if ( abs ( b ( 1 )). lt . small ) then messag = 'During the numerical solution the factor b(1)' // & & ' became too small !' ierror = 1000 !        call fatalerr ('tridag',messag) else ! ---   (2) decomposition and forward substitution beta = b ( 1 ) u ( 1 ) = r ( 1 ) / beta do i = 2 , n gamma ( i ) = c ( i - 1 ) / beta beta = b ( i ) - a ( i ) * gamma ( i ) ! ---     (2.1) if beta=0 then go to another algorithm including ! ---     elimination with pivoting if ( abs ( beta ). lt . small ) then messag = 'during the numerical solution the factor beta' // & & ' became too small !' ierror = 1000 + i !            call fatalerr ('tridag',messag) messag = messag ! for Forcheck return else u ( i ) = ( r ( i ) - a ( i ) * u ( i - 1 )) / beta end if enddo ! ---   (3) back substitution do i = n - 1 , 1 , - 1 u ( i ) = u ( i ) - gamma ( i + 1 ) * u ( i + 1 ) end do end if return end SUBROUTINE bandec ( a , n , m1 , m2 , np , mp , al , mpl , indx , d ) ! CHAPTER 2.4 Numerical Recipes implicit none INTEGER m1 , m2 , mp , mpl , n , np , indx ( n ) real ( 8 ) d , a ( np , mp ), al ( np , mpl ), TINY PARAMETER ( TINY = 1.d-20 ) !     Given an n.n band diagonal matrix A with m1 subdiagonal rows and m2 superdiagonal !     rows, compactly stored in the array a(1:n,1:m1+m2+1) as described in the comment for !     routine banmul, this routine constructs an LU decomposition of a rowwise permutation !     of A. The upper triangular matrix replaces a, while the lower triangular matrix is !     returned in al(1:n,1:m1). indx(1:n) is an output vector which records the row !     permutation effected by the partial pivoting; d is output as +1 or -1 depending on whether !     the number of row interchanges was even or odd, respectively. This routine is used !     in combination with banbks to solve band-diagonal sets of equations. INTEGER i , j , k , l , mm real ( 8 ) dum character ( len = 200 ) messag mm = m1 + m2 + 1 !      if(mm.gt.mp.or.m1.gt.mpl.or.n.gt.np) stop 'bad args in bandec' if ( mm . gt . mp . or . m1 . gt . mpl . or . n . gt . np ) then messag = 'bad args in bandec !' call fatalerr ( 'bandec' , messag ) endif l = m1 do i = 1 , m1 !   Rearrange the storage a bit. do j = m1 + 2 - i , mm a ( i , j - l ) = a ( i , j ) enddo l = l - 1 do j = mm - l , mm a ( i , j ) = 0.0d0 enddo enddo d = 1.0d0 l = m1 do k = 1 , n !  For each row... dum = a ( k , 1 ) i = k if ( l . lt . n ) l = l + 1 do j = k + 1 , l !  Find the pivot element. if ( abs ( a ( j , 1 )). gt . abs ( dum )) then dum = a ( j , 1 ) i = j endif enddo indx ( k ) = i if ( abs ( dum ). lt . 1.0d-20 ) a ( k , 1 ) = TINY !Matrix is algorithmically singular, but proceed anyway with TINY pivot !(desirable in some applications). if ( i . ne . k ) then !  Interchange rows. d =- d do j = 1 , mm dum = a ( k , j ) a ( k , j ) = a ( i , j ) a ( i , j ) = dum enddo endif do i = k + 1 , l !  Do the elimination. dum = a ( i , 1 ) / a ( k , 1 ) al ( k , i - k ) = dum do j = 2 , mm a ( i , j - 1 ) = a ( i , j ) - dum * a ( k , j ) enddo a ( i , mm ) = 0.0d0 enddo enddo return END SUBROUTINE banbks ( a , n , m1 , m2 , np , mp , al , mpl , indx , b ) ! CHAPTER 2.4 Numerical Recipes implicit none INTEGER m1 , m2 , mp , mpl , n , np , indx ( n ) real ( 8 ) a ( np , mp ), al ( np , mpl ), b ( n ) !     Given the arrays a, al, and indx as returned from bandec, and given a right-hand side !     vector b(1:n), solves the band diagonal linear equations A . x = b. The solution    !     vector x overwrites b(1:n). The other input arrays are not modified, and can be left !     in place for successive calls with different right-hand sides. INTEGER i , k , l , mm real ( 8 ) dum character ( len = 200 ) messag mm = m1 + m2 + 1 !      if(mm.gt.mp.or.m1.gt.mpl.or.n.gt.np) stop 'bad args in banbks' if ( mm . gt . mp . or . m1 . gt . mpl . or . n . gt . np ) then messag = 'bad args in banbks !' call fatalerr ( 'banbks' , messag ) endif l = m1 do k = 1 , n !  Forward substitution, unscrambling the permuted rows as we go i = indx ( k ) if ( i . ne . k ) then dum = b ( k ) b ( k ) = b ( i ) b ( i ) = dum endif if ( l . lt . n ) l = l + 1 do i = k + 1 , l b ( i ) = b ( i ) - al ( k , i - k ) * b ( k ) enddo enddo l = 1 do i = n , 1 , - 1 ! Backsubstitution. dum = b ( i ) do k = 2 , l dum = dum - a ( i , k ) * b ( k + i - 1 ) enddo b ( i ) = dum / a ( i , 1 ) if ( l . lt . mm ) l = l + 1 enddo return END","tags":"","loc":"sourcefile/tridag.f90.html"},{"title":"swap_csv_output.f90 – API reference SWAP","text":"Source Code module SWAP_csv_output use variables , only : igsnow , igird , iintc , irunon , iruno , ipeva , ievap , iqdra , iqbot , & gwl , pond , iptra , iqrot , iqreddry , iqredwet , iqredsol , iqredfrs , tsum , dvs , pgasspot , pgass , & cwdmpot , cwdm , wsopot , wso , wlvpot , wlv , wstpot , wst , wrtpot , wrt , dwso , dwlv , dwlvpot , dwst , dwstpot , dwrt , dwrtpot , & ch , cf , laipot , lai , rdpot , rd , tagppot , tagp , tagptpot , tagpt , cuptgrazpot , cuptgraz , plossdm , lossdm , & imsqprec , imsqirrig , imsqbot , imsqdra , imdectot , imrottot , sampro , solbal , & wc10 , Runoff_CN , iqtdo , iqtup , iqinfmax , TeTop , TeBot , ies0 , iet0 , iew0 , inrai , inird , volact , ssnow , iqssdi , & flprintshort , date , t1900 , dz , numnod , zbotcp , ztopcp , H , theta , K , Tsoil , cml , cmsy , inq , inqrot , & igrai , isnrai , iqmpoutdrrap , irunocn , isubl , c_top , heacap , heacon , inqssdi , inqdra , nrlevs , frarmtrx , & iqdo , iqup , inqdra_in , inqdra_out , pathwork , outfil , project , InList_csv , macp , madr implicit none private public :: csv_out ! local list integer , parameter :: M = 103 ! total number of variables present in predefined list integer , parameter :: Mnodes = 10 ! Maximum number of nodes (Mnodes) or sub-regions (Mnodes/2; since lower and upper node are needed); MUST BE EVEN !!! type output character ( len = 12 ), dimension ( M ) :: name ! base name of variable character ( len = 12 ), dimension ( M ) :: unit ! units of variable character ( len = 24 ), dimension ( Mnodes , M ) :: head ! specific header name of variable (when necessary: including depth/node number between []) integer , dimension ( M ) :: iyes ! yes (1) or no (1) variable is requested for output real ( 8 ), dimension ( Mnodes , M ) :: value ! value of variable; up to maximum of nodes [Mnodes] or in case of sub-regions [Mnodes/2] integer , dimension ( M ) :: Nnodes ! actual number of nodes/subregions; if non-nodal information then Nnodes = 1 integer , dimension ( Mnodes , M ) :: nodes ! node numbers for [] output (nodes or sub-region) end type output type local_pointer logical :: fldo integer :: jpos real ( 8 ), dimension ( Mnodes ) :: vals end type local_pointer integer , parameter :: Msn = 7 ! Maximum number of shortnames type shortnames integer :: nsn integer , dimension ( Msn ) :: n character ( len = 20 ), dimension ( Msn ) :: alias character ( len = 20 ), dimension ( Msn , M ) :: names end type shortnames ! all variables related information type ( output ), save :: vars ! short names for input type ( shortnames ), save :: shorts ! local pointers: per compartment type ( local_pointer ), save :: lp_H , lp_WC , lp_K type ( local_pointer ), save :: lp_C , lp_CA , lp_O2 type ( local_pointer ), save :: lp_T , lp_HCA , lp_HCO type ( local_pointer ), save :: lp_DRA , lp_RWU , lp_Q , lp_SI ! local pointers: sub-regions type ( local_pointer ), save :: lp_WTOT , lp_QTRA , lp_QTOP , lp_QBOT , lp_QDRA type ( local_pointer ), save :: lp_QTIN , lp_QTOU , lp_QBIN , lp_QBOU type ( local_pointer ), save :: lp_QDIN , lp_QDOU ! local help pointers real ( 8 ) :: dstor , baldev ! other local help real ( 8 ), save :: VolOld , PondOld , SnowOld ! user input names character ( len = 2096 ) :: InList character ( len = 512 ), dimension ( M ) :: userlist integer :: nlist ! dummy integer :: i ! initial; allowed list of input and units that apply; this sequence determines sequence in output file ! MUST be uppercase ! Sequence here determines sequence in output file data ( vars % name ( i ), vars % unit ( i ), i = 1 , M ) / & 'RAIN' , '(cm)' , & 'RAIN_NET' , '(cm)' , & 'SNOW' , '(cm)' , & 'IRRIG' , '(cm)' , & 'IRRIG_NET' , '(cm)' , & 'INTERC' , '(cm)' , & 'RUNON' , '(cm)' , & 'RUNOFF' , '(cm)' , & 'EPOT' , '(cm)' , & 'EACT' , '(cm)' , & 'SUBLIM' , '(cm)' , & 'DRAINAGE' , '(cm)' , & 'QBOTTOM' , '(cm)' , & 'GWL' , '(cm)' , & 'POND' , '(cm)' , & 'SSNOW' , '(cm)' , & 'TPOT' , '(cm)' , & 'TACT' , '(cm)' , & 'TREDDRY' , '(cm)' , & 'TREDWET' , '(cm)' , & 'TREDSOL' , '(cm)' , & 'TREDFRS' , '(cm)' , & 'ES0' , '(cm)' , & 'ET0' , '(cm)' , & 'EW0' , '(cm)' , & 'DSTOR' , '(cm)' , & 'BALDEV' , '(cm)' , & 'VOLACT' , '(cm)' , & 'QSSDI' , '(cm)' , & 'TSUM' , '(deg C)' , & 'DVS' , '(-)' , & 'PGASSPOT' , '(kgch/ha)' , & 'PGASS' , '(kgch/ha)' , & 'CPWDM' , '(kg/ha)' , & 'CWDM' , '(kg/ha)' , & 'CPWSO' , '(kg/ha)' , & 'CWSO' , '(kg/ha)' , & 'PWLV' , '(kg/ha)' , & 'WLV' , '(kg/ha)' , & 'PWST' , '(kg/ha)' , & 'WST' , '(kg/ha)' , & 'PWRT' , '(kg/ha)' , & 'WRT' , '(kg/ha)' , & 'DWSO' , '(kg/ha)' , & 'DWLV' , '(kg/ha)' , & 'DWLVPOT' , '(kg/ha)' , & 'DWST' , '(kg/ha)' , & 'DWSTPOT' , '(kg/ha)' , & 'DWRT' , '(kg/ha)' , & 'DWRTPOT' , '(kg/ha)' , & 'HEIGHT' , '(cm)' , & 'CRPFAC' , '(-)' , & 'LAIPOT' , '(m2/m2)' , & 'LAI' , '(m2/m2)' , & 'RDPOT' , '(cm)' , & 'RD' , '(cm)' , & 'PGRASSDM' , '(kg/ha)' , & 'GRASSDM' , '(kg/ha)' , & 'PMOWDM' , '(kg/ha)' , & 'MOWDM' , '(kg/ha)' , & 'PGRAZDM' , '(kg/ha)' , & 'GRAZDM' , '(kg/ha)' , & 'PLOSSDM' , '(kg/ha)' , & 'LOSSDM' , '(kg/ha)' , & 'SQPREC' , '(g/cm2)' , & 'SQIRRIG' , '(g/cm2)' , & 'SQBOT' , '(g/cm2)' , & 'SQDRA' , '(g/cm2)' , & 'DECTOT' , '(g/cm2)' , & 'ROTTOT' , '(g/cm2)' , & 'SAMPRO' , '(g/cm2)' , & 'SOLBAL' , '(g/cm2)' , & 'WC10' , '(cm3/cm3)' , & 'RUNOFFCN' , '(cm) ' , & 'QTOPIN' , '(cm) ' , & 'QTOPOUT' , '(cm) ' , & 'QINFMAX' , '(cm)' , & 'H[' , '(cm)' , & 'WC[' , '(cm3/cm3)' , & 'TEMP[' , '(deg C)' , & 'K[' , '(cm/d)' , & 'CONC[' , '(g/cm3 w)' , & 'CONCADS[' , '(g/cm3)' , & 'O2TOP[' , '(kg/m3)' , & 'HEACAP[' , '(J/cm3/K)' , & 'HEACON[' , '(J/cm/K/d)' , & 'TETOP' , '(deg C)' , & 'TEBOT' , '(deg C)' , & 'DRAIN[' , '(cm)' , & 'RWU[' , '(cm)' , & 'FLUX[' , '(cm)' , & 'SSDI[' , '(cm)' , & 'WTOT[' , '(cm)' , & 'QTRANS[' , '(cm)' , & 'QTOP[' , '(cm)' , & 'QBOT[' , '(cm)' , & 'QDRA[' , '(cm)' , & 'QTOPIN[' , '(cm)' , & 'QTOPOUT[' , '(cm)' , & 'QBOTIN[' , '(cm)' , & 'QBOTOUT[' , '(cm)' , & 'QDRAININ[' , '(cm)' , & 'QDRAINOUT[' , '(cm)' & / ! must take care on number of items provided data shorts % nsn / 7 / data shorts % n ( 1 : 7 ) / 17 , 8 , 8 , 33 , 21 , 5 , 11 / ! shorts%nsn values data shorts % alias ( 1 : 7 ) / \"WATBAL\" , \"SOLBAL\" , \"ETTERMS\" , \"CROP\" , \"GRASS\" , & ! shorts%nsn values \"SUBREG_MIN\" , \"SUBREG_ALL\" / data shorts % names ( 1 , 1 : 17 ) / \"RAIN\" , \"SNOW\" , \"INTERC\" , \"RUNON\" , \"RUNOFF\" , & ! shorts%n(1) values \"IRRIG\" , \"TPOT\" , \"TACT\" , \"EPOT\" , \"EACT\" , & \"SUBLIM\" , \"QSSDI\" , \"QBOTTOM\" , \"DRAINAGE\" , \"VOLACT\" , & \"DSTOR\" , \"BALDEV\" / data shorts % names ( 2 , 1 : 8 ) / \"SQPREC\" , \"SQIRRIG\" , \"SQBOT\" , \"DECTOT\" , \"ROTTOT\" , & ! shorts%n(2) values \"SQDRA\" , \"SAMPRO\" , \"SOLBAL\" / data shorts % names ( 3 , 1 : 8 ) / \"TPOT\" , \"TACT\" , \"TREDDRY\" , \"TREDWET\" , \"TREDSOL\" , & ! shorts%n(3) values \"TREDFRS\" , \"EPOT\" , \"EACT\" / data shorts % names ( 4 , 1 : 33 ) / \"TPOT\" , \"TACT\" , \"TREDDRY\" , \"TREDWET\" , \"TREDSOL\" , & ! shorts%n(4) values \"TREDFRS\" , \"TSUM\" , \"DVS\" , \"PGASSPOT\" , \"PGASS\" , & \"CPWDM\" , \"CWDM\" , \"CPWSO\" , \"CWSO\" , \"PWLV\" , & \"WLV\" , \"PWST\" , \"WST\" , \"PWRT\" , \"WRT\" , & \"DWSO\" , \"DWLV\" , \"DWLVPOT\" , \"DWST\" , \"DWSTPOT\" , & \"DWRT\" , \"DWRTPOT\" , \"HEIGHT\" , \"CRPFAC\" , \"LAIPOT\" , & \"LAI\" , \"RDPOT\" , \"RD\" / data shorts % names ( 5 , 1 : 21 ) / \"TPOT\" , \"TACT\" , \"TREDDRY\" , \"TREDWET\" , \"TREDSOL\" , & ! shorts%n(5) values \"TREDFRS\" , \"TSUM\" , \"HEIGHT\" , \"CRPFAC\" , \"LAIPOT\" , & \"LAI\" , \"RDPOT\" , \"RD\" , \"PGRASSDM\" , \"GRASSDM\" , & \"PMOWDM\" , \"MOWDM\" , \"PGRAZDM\" , \"GRAZDM\" , \"PLOSSDM\" , & \"LOSSDM\" / data shorts % names ( 6 , 1 : 5 ) / \"WTOT\" , \"QTRANS\" , \"QTOP\" , \"QBOT\" , \"QDRA\" / ! shorts%n(6) values data shorts % names ( 7 , 1 : 11 ) / \"WTOT\" , \"QTRANS\" , \"QTOP\" , \"QBOT\" , \"QDRA\" , & ! shorts%n(7) values \"QTOPIN\" , \"QTOPOUT\" , \"QBOTIN\" , \"QBOTOUT\" , \"QDRAININ\" , & \"QDRAINOUT\" / contains subroutine set_values implicit none integer :: i ! this must be hard-coded ! this provides the actual link between user-supplied name and internal variable name (MUST be uppercase) do concurrent ( i = 1 : M , vars % iyes ( i ) == 1 ) ! single valued vars if ( vars % name ( i ) == 'RAIN' ) vars % value ( 1 , i ) = igrai + isnrai if ( vars % name ( i ) == 'RAIN_NET' ) vars % value ( 1 , i ) = inrai if ( vars % name ( i ) == 'SNOW' ) vars % value ( 1 , i ) = igsnow if ( vars % name ( i ) == 'IRRIG' ) vars % value ( 1 , i ) = igird if ( vars % name ( i ) == 'IRRIG_NET' ) vars % value ( 1 , i ) = inird if ( vars % name ( i ) == 'INTERC' ) vars % value ( 1 , i ) = iintc if ( vars % name ( i ) == 'RUNON' ) vars % value ( 1 , i ) = irunon if ( vars % name ( i ) == 'RUNOFF' ) vars % value ( 1 , i ) = iruno if ( vars % name ( i ) == 'EPOT' ) vars % value ( 1 , i ) = ipeva if ( vars % name ( i ) == 'EACT' ) vars % value ( 1 , i ) = ievap if ( vars % name ( i ) == 'SUBLIM' ) vars % value ( 1 , i ) = isubl if ( vars % name ( i ) == 'DRAINAGE' ) vars % value ( 1 , i ) = iqdra + iQMpOutDrRap if ( vars % name ( i ) == 'QBOTTOM' ) vars % value ( 1 , i ) = iqbot if ( vars % name ( i ) == 'GWL' ) vars % value ( 1 , i ) = gwl if ( vars % name ( i ) == 'POND' ) vars % value ( 1 , i ) = pond if ( vars % name ( i ) == 'TPOT' ) vars % value ( 1 , i ) = iptra if ( vars % name ( i ) == 'TACT' ) vars % value ( 1 , i ) = iqrot if ( vars % name ( i ) == 'TREDDRY' ) vars % value ( 1 , i ) = iqreddry if ( vars % name ( i ) == 'TREDWET' ) vars % value ( 1 , i ) = iqredwet if ( vars % name ( i ) == 'TREDSOL' ) vars % value ( 1 , i ) = iqredsol if ( vars % name ( i ) == 'TREDFRS' ) vars % value ( 1 , i ) = iqredfrs if ( vars % name ( i ) == 'ES0' ) vars % value ( 1 , i ) = ies0 if ( vars % name ( i ) == 'ET0' ) vars % value ( 1 , i ) = iet0 if ( vars % name ( i ) == 'EW0' ) vars % value ( 1 , i ) = iew0 if ( vars % name ( i ) == 'DSTOR' ) vars % value ( 1 , i ) = dstor if ( vars % name ( i ) == 'BALDEV' ) vars % value ( 1 , i ) = baldev if ( vars % name ( i ) == 'VOLACT' ) vars % value ( 1 , i ) = volact if ( vars % name ( i ) == 'SSNOW' ) vars % value ( 1 , i ) = ssnow if ( vars % name ( i ) == 'QSSDI' ) vars % value ( 1 , i ) = iqssdi if ( vars % name ( i ) == 'TSUM' ) vars % value ( 1 , i ) = tsum if ( vars % name ( i ) == 'DVS' ) vars % value ( 1 , i ) = dvs if ( vars % name ( i ) == 'PGASSPOT' ) vars % value ( 1 , i ) = pgasspot if ( vars % name ( i ) == 'PGASS' ) vars % value ( 1 , i ) = pgass if ( vars % name ( i ) == 'CPWDM' ) vars % value ( 1 , i ) = cwdmpot if ( vars % name ( i ) == 'CWDM' ) vars % value ( 1 , i ) = cwdm if ( vars % name ( i ) == 'CPWSO' ) vars % value ( 1 , i ) = wsopot if ( vars % name ( i ) == 'CWSO' ) vars % value ( 1 , i ) = wso if ( vars % name ( i ) == 'PWLV' ) vars % value ( 1 , i ) = wlvpot if ( vars % name ( i ) == 'WLV' ) vars % value ( 1 , i ) = wlv if ( vars % name ( i ) == 'PWST' ) vars % value ( 1 , i ) = wstpot if ( vars % name ( i ) == 'WST' ) vars % value ( 1 , i ) = wst if ( vars % name ( i ) == 'PWRT' ) vars % value ( 1 , i ) = wrtpot if ( vars % name ( i ) == 'WRT' ) vars % value ( 1 , i ) = wrt if ( vars % name ( i ) == 'DWSO' ) vars % value ( 1 , i ) = dwso if ( vars % name ( i ) == 'DWLV' ) vars % value ( 1 , i ) = dwlv if ( vars % name ( i ) == 'DWLVPOT' ) vars % value ( 1 , i ) = dwlvpot if ( vars % name ( i ) == 'DWST' ) vars % value ( 1 , i ) = dwst if ( vars % name ( i ) == 'DWSTPOT' ) vars % value ( 1 , i ) = dwstpot if ( vars % name ( i ) == 'DWRT' ) vars % value ( 1 , i ) = dwrt if ( vars % name ( i ) == 'DWRTPOT' ) vars % value ( 1 , i ) = dwrtpot if ( vars % name ( i ) == 'HEIGHT' ) vars % value ( 1 , i ) = ch if ( vars % name ( i ) == 'CRPFAC' ) vars % value ( 1 , i ) = cf if ( vars % name ( i ) == 'LAIPOT' ) vars % value ( 1 , i ) = laipot if ( vars % name ( i ) == 'LAI' ) vars % value ( 1 , i ) = lai if ( vars % name ( i ) == 'RDPOT' ) vars % value ( 1 , i ) = rdpot if ( vars % name ( i ) == 'RD' ) vars % value ( 1 , i ) = rd if ( vars % name ( i ) == 'PGRASSDM' ) vars % value ( 1 , i ) = tagppot if ( vars % name ( i ) == 'GRASSDM' ) vars % value ( 1 , i ) = tagp if ( vars % name ( i ) == 'PMOWDM' ) vars % value ( 1 , i ) = tagptpot if ( vars % name ( i ) == 'MOWDM' ) vars % value ( 1 , i ) = tagpt if ( vars % name ( i ) == 'PGRAZDM' ) vars % value ( 1 , i ) = cuptgrazpot if ( vars % name ( i ) == 'GRAZDM' ) vars % value ( 1 , i ) = cuptgraz if ( vars % name ( i ) == 'PLOSSDM' ) vars % value ( 1 , i ) = plossdm if ( vars % name ( i ) == 'LOSSDM' ) vars % value ( 1 , i ) = lossdm if ( vars % name ( i ) == 'SQPREC' ) vars % value ( 1 , i ) = imsqprec if ( vars % name ( i ) == 'SQIRRIG' ) vars % value ( 1 , i ) = imsqirrig if ( vars % name ( i ) == 'SQBOT' ) vars % value ( 1 , i ) = imsqbot if ( vars % name ( i ) == 'SQDRA' ) vars % value ( 1 , i ) = imsqdra if ( vars % name ( i ) == 'DECTOT' ) vars % value ( 1 , i ) = imdectot if ( vars % name ( i ) == 'ROTTOT' ) vars % value ( 1 , i ) = imrottot if ( vars % name ( i ) == 'SAMPRO' ) vars % value ( 1 , i ) = sampro if ( vars % name ( i ) == 'SOLBAL' ) vars % value ( 1 , i ) = solbal if ( vars % name ( i ) == 'WC10' ) vars % value ( 1 , i ) = wc10 if ( vars % name ( i ) == 'RUNOFFCN' ) vars % value ( 1 , i ) = Runoff_CN if ( vars % name ( i ) == 'QTOPIN' ) vars % value ( 1 , i ) = iqtdo if ( vars % name ( i ) == 'QTOPOUT' ) vars % value ( 1 , i ) = iqtup if ( vars % name ( i ) == 'QINFMAX' ) vars % value ( 1 , i ) = iqinfmax if ( vars % name ( i ) == 'TETOP' ) vars % value ( 1 , i ) = TeTop if ( vars % name ( i ) == 'TEBOT' ) vars % value ( 1 , i ) = TeBot ! vars per layer if ( vars % name ( i ) == 'H[' ) vars % value ( 1 : Mnodes , i ) = lp_H % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'WC[' ) vars % value ( 1 : Mnodes , i ) = lp_WC % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'TEMP[' ) vars % value ( 1 : Mnodes , i ) = lp_T % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'K[' ) vars % value ( 1 : Mnodes , i ) = lp_K % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'CONC[' ) vars % value ( 1 : Mnodes , i ) = lp_C % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'CONCADS[' ) vars % value ( 1 : Mnodes , i ) = lp_CA % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'O2TOP[' ) vars % value ( 1 : Mnodes , i ) = lp_O2 % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'HEACAP[' ) vars % value ( 1 : Mnodes , i ) = lp_HCA % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'HEACON[' ) vars % value ( 1 : Mnodes , i ) = lp_HCO % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'DRAIN[' ) vars % value ( 1 : Mnodes , i ) = lp_DRA % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'RWU[' ) vars % value ( 1 : Mnodes , i ) = lp_RWU % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'FLUX[' ) vars % value ( 1 : Mnodes , i ) = lp_Q % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'SSDI[' ) vars % value ( 1 : Mnodes , i ) = lp_SI % vals ( 1 : Mnodes ) ! values for subregions if ( vars % name ( i ) == 'WTOT[' ) vars % value ( 1 : Mnodes , i ) = lp_WTOT % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QTRANS[' ) vars % value ( 1 : Mnodes , i ) = lp_QTRA % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QTOP[' ) vars % value ( 1 : Mnodes , i ) = lp_QTOP % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QBOT[' ) vars % value ( 1 : Mnodes , i ) = lp_QBOT % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QDRA[' ) vars % value ( 1 : Mnodes , i ) = lp_QDRA % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QTOPIN[' ) vars % value ( 1 : Mnodes , i ) = lp_QTIN % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QTOPOUT[' ) vars % value ( 1 : Mnodes , i ) = lp_QTOU % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QBOTIN[' ) vars % value ( 1 : Mnodes , i ) = lp_QBIN % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QBOTOUT[' ) vars % value ( 1 : Mnodes , i ) = lp_QBOU % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QDRAININ[' ) vars % value ( 1 : Mnodes , i ) = lp_QDIN % vals ( 1 : Mnodes ) if ( vars % name ( i ) == 'QDRAINOUT[' ) vars % value ( 1 : Mnodes , i ) = lp_QDOU % vals ( 1 : Mnodes ) end do end subroutine set_values subroutine csv_out ( iTask ) implicit none ! global integer , intent ( in ) :: iTask ! local integer :: j , il , iuncsv character ( len = 19 ) :: datexti character ( len = 1024 ) :: line character ( len = 300 ) :: filcsv character ( len = 20 ) :: form character ( len = 30 ) :: myval ! functions integer :: getun save :: iuncsv select case ( iTask ) case ( 1 ) ! initial values in vars vars % iyes ( 1 : M ) = 0 vars % value ( 1 : Mnodes , 1 : M ) = - 99 9.9d0 vars % Nnodes ( 1 : M ) = 1 vars % nodes ( 1 : Mnodes , 1 : M ) = 0 ! Set format for output call what_form ( 1 ) ! to be based on user input information !      InList = 'H[-10.0,4,5], RAIN, WC[2,3,6], H[4], WTOT[0:-15.0,4:6], Tact, WC[1], WC[-2], WC[1], rain,GWL, RWU[1,2,3,4,5,6], QTRANS[1:3,4:6], qtopin[0:-30]' Inlist = InList_csv ! extract all individual vars from InList; remove double entries; merge same vars with [] in single var with []; determine which vars are require call make_userlist ( InList ) call merge call det_which_vars ! output file; write header iuncsv = getun ( 500 , 900 ) filcsv = trim ( pathwork ) // trim ( outfil ) // '_output.csv' open ( unit = iuncsv , file = filcsv , status = \"unknown\" ) call makeheader ( iuncsv , filcsv ) ! store inital values VolOld = volact PondOld = pond SnowOld = ssnow case ( 2 ) ! dynamic ! some local pointers must be filled here first; then values are transferred to vars%values call fill_values call set_values ! line contains results in comma-separated format; il is its length ! time is first value line = \"\" ; il = 0 if (. not . flprintshort ) then call addstr ( line , il , trim ( date )); call addstr ( line , il , \",\" ) else ! determine date-time call dtdpst ( 'year-month-day hour:minute:seconds' , t1900 , datexti ) call addstr ( line , il , trim ( datexti )); call addstr ( line , il , \",\" ) end if ! next: add all desired values do j = 1 , M if ( vars % iyes ( j ) == 1 ) then do i = 1 , vars % Nnodes ( j ) call what_form ( 2 , vars % value ( i , j ), form ) write ( myval , form ) vars % value ( i , j ) line = line ( 1 : il ) // trim ( adjustl ( myval )); il = len_trim ( line ) end do end if end do ! write result (skip last character which is a comma) write ( iuncsv , '(A)' ) line ( 1 : il - 1 ) case ( 3 ) close ( unit = iuncsv ) case default call fatalerr ( \"csv_out\" , \"Illegal iTask\" ) end select end subroutine csv_out subroutine what_form ( iTask , var , form ) implicit none ! global integer , intent ( in ) :: iTask real ( 8 ), intent ( in ), optional :: var character ( len =* ), intent ( out ), optional :: form ! local ! when to automatically swith from F to E formatting integer , parameter :: num_d = 5 ! # of decimals; later: user input? integer , parameter :: num_w = num_d + 7 ! total width of format, for E-formatting: 7 positions are needed for \"-x.\"at start and \"E+00\" at end integer , parameter :: expo = 4 real ( 8 ), parameter :: t1 = 1.0d0 / ( 1 0.0d0 ** expo ) real ( 8 ), parameter :: t2 = 1 0.0d0 ** expo character ( len = 2 ) :: cval1 , cval2 character ( len = 20 ), save :: form_rea_F1 , form_rea_E1 , form_rea_F0 if ( iTask == 1 ) then ! some basic info !  Note: field width of zero in I and F edit descriptors is allowed as of Fortran95 to ensure as little space usage !        in output file as possible (Metcalf et al., 2004, Fortran 95/2003 explained, Oxford Univ. Prrss, p. 199) write ( cval1 , '(I0)' ) num_d write ( cval2 , '(I0)' ) num_w form_rea_F0 = '(F0.0,\",\")' form_rea_F1 = '(F0.' // trim ( cval1 ) // ',\",\")' form_rea_E1 = '(1P,E' // trim ( cval2 ) // '.' // trim ( cval1 ) // ',\",\")' else if ( abs ( var ) < 1.0D-10 ) then form = form_rea_F0 else if ( abs ( var ) < t1 . OR . abs ( var ) > t2 ) then form = form_rea_E1 else form = form_rea_F1 end if end if end subroutine what_form subroutine fill_values implicit none integer :: i ! change in storage and deviation in mass balance dstor = ( volact + pond + ssnow ) - ( VolOld + PondOld + SnowOld ) baldev = ( igrai + isnrai + igsnow + igird + irunon + iqssdi ) - dstor - & ( iintc + iruno + irunoCN + iqrot + ievap + isubl + iQMpOutDrRap + iqdra + ( - 1.0d0 * iqbot )) ! replace Old values by current values (needed for next output moment) VolOld = volact PondOld = pond SnowOld = ssnow ! H, WC, TEMP, K, CONC, CONCADS, O2TOP if ( lp_H % fldo ) lp_H % vals ( 1 : vars % Nnodes ( lp_H % jpos )) = H ( vars % nodes ( 1 : vars % Nnodes ( lp_H % jpos ), lp_H % jpos )) if ( lp_WC % fldo ) lp_WC % vals ( 1 : vars % Nnodes ( lp_WC % jpos )) = theta ( vars % nodes ( 1 : vars % Nnodes ( lp_WC % jpos ), lp_WC % jpos )) if ( lp_K % fldo ) lp_K % vals ( 1 : vars % Nnodes ( lp_K % jpos )) = K ( vars % nodes ( 1 : vars % Nnodes ( lp_K % jpos ), lp_K % jpos )) if ( lp_T % fldo ) lp_T % vals ( 1 : vars % Nnodes ( lp_T % jpos )) = Tsoil ( vars % nodes ( 1 : vars % Nnodes ( lp_T % jpos ), lp_T % jpos )) if ( lp_C % fldo ) lp_C % vals ( 1 : vars % Nnodes ( lp_C % jpos )) = cml ( vars % nodes ( 1 : vars % Nnodes ( lp_C % jpos ), lp_C % jpos )) if ( lp_CA % fldo ) lp_CA % vals ( 1 : vars % Nnodes ( lp_CA % jpos )) = cmsy ( vars % nodes ( 1 : vars % Nnodes ( lp_CA % jpos ), lp_CA % jpos )) if ( lp_O2 % fldo ) lp_O2 % vals ( 1 : vars % Nnodes ( lp_O2 % jpos )) = c_top ( vars % nodes ( 1 : vars % Nnodes ( lp_O2 % jpos ), lp_O2 % jpos )) ! HEACAP, HEACON, DRAIN, RWU, FLUX, SSDI if ( lp_HCA % fldo ) lp_HCA % vals ( 1 : vars % Nnodes ( lp_HCA % jpos )) = HEACAP ( vars % nodes ( 1 : vars % Nnodes ( lp_HCA % jpos ), lp_HCA % jpos )) if ( lp_HCO % fldo ) lp_HCO % vals ( 1 : vars % Nnodes ( lp_HCO % jpos )) = HEACON ( vars % nodes ( 1 : vars % Nnodes ( lp_HCO % jpos ), lp_HCO % jpos )) if ( lp_RWU % fldo ) lp_RWU % vals ( 1 : vars % Nnodes ( lp_RWU % jpos )) = inqrot ( vars % nodes ( 1 : vars % Nnodes ( lp_RWU % jpos ), lp_RWU % jpos )) if ( lp_Q % fldo ) lp_Q % vals ( 1 : vars % Nnodes ( lp_Q % jpos )) = inq ( vars % nodes ( 1 : vars % Nnodes ( lp_Q % jpos ), lp_Q % jpos )) if ( lp_SI % fldo ) lp_SI % vals ( 1 : vars % Nnodes ( lp_SI % jpos )) = inqssdi ( vars % nodes ( 1 : vars % Nnodes ( lp_SI % jpos ), lp_SI % jpos )) ! summed for all drainage levels if ( lp_DRA % fldo ) then do i = 1 , vars % Nnodes ( lp_DRA % jpos ); lp_DRA % vals ( i ) = sum ( inqdra ( 1 : nrlevs , i )); end do end if ! handle subregions: WTOT, QTRANS, QTOP, QBOT, QDRA, lp_QTIN, lp_QTOU, lp_QBIN, lp_QBOU, lp_QDIN, lp_QDOU if ( lp_WTOT % fldo ) call fill_1 ( vars % Nnodes ( lp_WTOT % jpos ), lp_WTOT % jpos , vars % nodes , lp_WTOT % vals , 1 , theta , dz , FrArMtrx ) ! summed sink-terms inside subregion if ( lp_QTRA % fldo ) call fill_1 ( vars % Nnodes ( lp_QTRA % jpos ), lp_QTRA % jpos , vars % nodes , lp_QTRA % vals , 0 , inqrot ) if ( lp_QDRA % fldo ) call fill_2 ( vars % Nnodes ( lp_QDRA % jpos ), lp_QDRA % jpos , vars % nodes , lp_QDRA % vals , nrlevs , inqdra ) if ( lp_QDIN % fldo ) call fill_2 ( vars % Nnodes ( lp_QDIN % jpos ), lp_QDIN % jpos , vars % nodes , lp_QDIN % vals , nrlevs , inqdra_in ) if ( lp_QDOU % fldo ) call fill_2 ( vars % Nnodes ( lp_QDOU % jpos ), lp_QDOU % jpos , vars % nodes , lp_QDOU % vals , nrlevs , inqdra_out ) ! fluxes at top and bottom boudanries of subregions if ( lp_QTOP % fldo ) call fill_3 ( vars % Nnodes ( lp_QTOP % jpos ), lp_QTOP % jpos , 1 , 0 , vars % nodes , lp_QTOP % vals , - inq ) if ( lp_QBOT % fldo ) call fill_3 ( vars % Nnodes ( lp_QBOT % jpos ), lp_QBOT % jpos , 0 , 1 , vars % nodes , lp_QBOT % vals , - inq ) if ( lp_QTIN % fldo ) call fill_3 ( vars % Nnodes ( lp_QTIN % jpos ), lp_QTIN % jpos , 1 , 0 , vars % nodes , lp_QTIN % vals , iqdo ) if ( lp_QTOU % fldo ) call fill_3 ( vars % Nnodes ( lp_QTOU % jpos ), lp_QTOU % jpos , 1 , 0 , vars % nodes , lp_QTOU % vals , iqup ) if ( lp_QBIN % fldo ) call fill_3 ( vars % Nnodes ( lp_QBIN % jpos ), lp_QBIN % jpos , 0 , 1 , vars % nodes , lp_QBIN % vals , iqup ) if ( lp_QBOU % fldo ) call fill_3 ( vars % Nnodes ( lp_QBOU % jpos ), lp_QBOU % jpos , 0 , 1 , vars % nodes , lp_QBOU % vals , iqdo ) end subroutine fill_values subroutine fill_1 ( Nnodes , jpos , nodes , vals , iwtot , swap_vals , dz , fr ) ! global integer , intent ( in ) :: Nnodes , jpos , iwtot integer , dimension ( Mnodes , M ), intent ( in ) :: nodes real ( 8 ), dimension ( Nnodes ), intent ( out ) :: vals real ( 8 ), dimension ( macp ), intent ( in ) :: swap_vals real ( 8 ), dimension ( macp ), intent ( in ), optional :: dz , fr ! local integer :: i , j do i = 1 , Nnodes vals ( i ) = 0.0d0 do j = nodes ( 2 * i - 1 , jpos ), nodes ( 2 * i , jpos ) if ( iwtot /= 0 ) then vals ( i ) = vals ( i ) + swap_vals ( j ) * dz ( j ) * fr ( j ) else vals ( i ) = vals ( i ) + swap_vals ( j ) end if end do end do end subroutine fill_1 subroutine fill_2 ( Nnodes , jpos , nodes , vals , nrlevs , swap_vals ) ! global integer , intent ( in ) :: Nnodes , jpos , nrlevs integer , dimension ( Mnodes , M ), intent ( in ) :: nodes real ( 8 ), dimension ( Nnodes ), intent ( out ) :: vals real ( 8 ), dimension ( madr , macp ), intent ( in ) :: swap_vals ! local integer :: i , j do i = 1 , Nnodes vals ( i ) = 0.0d0 do j = nodes ( 2 * i - 1 , jpos ), nodes ( 2 * i , jpos ) vals ( i ) = vals ( i ) + sum ( swap_vals ( 1 : nrlevs , j )) end do end do end subroutine fill_2 subroutine fill_3 ( Nnodes , jpos , low , raise , nodes , vals , swap_vals ) ! global integer , intent ( in ) :: Nnodes , jpos , low , raise integer , dimension ( Mnodes , M ), intent ( in ) :: nodes real ( 8 ), dimension ( Nnodes ), intent ( out ) :: vals real ( 8 ), dimension ( macp ), intent ( in ) :: swap_vals ! local integer :: i , j do i = 1 , Nnodes j = nodes ( 2 * i - low , jpos ) vals ( i ) = swap_vals ( j + raise ) end do end subroutine fill_3 subroutine makeheader ( iuncsv , filcsv ) implicit none integer , intent ( in ) :: iuncsv character ( len =* ), intent ( in ) :: filcsv character ( len = 1024 ) :: header_units , header_names integer :: il1 , il2 , j , k ! write universal SWAP header call writehead ( iuncsv , 1 , filcsv , 'specified output data of SWAP' , project ) ! typical csv header lines: (units, names) header_units = \"* (d)\" ; il1 = len_trim ( header_units ) header_names = \"DATETIME\" ; il2 = len_trim ( header_names ) do j = 1 , M if ( vars % iyes ( j ) == 1 ) then do k = 1 , vars % Nnodes ( j ) call addstr ( header_units , il1 , \",\" // vars % unit ( j )) call addstr ( header_names , il2 , \",\" // vars % head ( k , j )) end do end if end do write ( iuncsv , '(A)' ) trim ( header_units ) write ( iuncsv , '(A)' ) trim ( header_names ) end subroutine makeheader subroutine det_which_vars () implicit none ! global ! local integer :: i , j , ipos1 , ipos2 vars % iyes = 0 do i = 1 , nlist do j = 1 , M ipos1 = index ( userlist ( i ), \"[\" ) if ( ipos1 == 0 ) then if ( userlist ( i ) == vars % name ( j )) then vars % iyes ( j ) = 1 vars % head ( 1 , j ) = vars % name ( j ) end if else if ( userlist ( i )( 1 : ipos1 ) == vars % name ( j )) then vars % iyes ( j ) = 1 ipos2 = index ( userlist ( i ), \"]\" ) call handle_sqr_brackets ( i , j , ipos1 , ipos2 ) end if end if end do end do end subroutine det_which_vars subroutine handle_sqr_brackets ( i , j , ipos1 , ipos2 ) implicit none ! global integer , intent ( in ) :: i , j , ipos1 , ipos2 ! words integer , parameter :: ilw = Mnodes integer , dimension ( ilw ) :: iwbeg , iwend integer :: ifnd , iwar , k , ktel , ipos3 character ( len =* ), parameter :: colon = \":\" character ( len =* ), parameter :: semicolon = \";\" character ( len = 256 ) :: str , substr , name real :: rv logical :: isSUB isSUB = . false . name = userlist ( i )( 1 : ipos1 - 1 ) ! H, WC, TEMP, K, CONC, CONCADS, O2TOP if ( name == \"H\" ) then ; lp_H % fldo = . true .; lp_H % jpos = j ; end if if ( name == \"WC\" ) then ; lp_WC % fldo = . true .; lp_WC % jpos = j ; end if if ( name == \"TEMP\" ) then ; lp_T % fldo = . true .; lp_T % jpos = j ; end if if ( name == \"K\" ) then ; lp_K % fldo = . true .; lp_K % jpos = j ; end if if ( name == \"CONC\" ) then ; lp_C % fldo = . true .; lp_C % jpos = j ; end if if ( name == \"CONCADS\" ) then ; lp_CA % fldo = . true .; lp_CA % jpos = j ; end if if ( name == \"O2TOP\" ) then ; lp_O2 % fldo = . true .; lp_O2 % jpos = j ; end if ! HEACAP, HEACON, DRAIN, RWU, FLUX, SSDI if ( name == \"HEACAP\" ) then ; lp_HCA % fldo = . true .; lp_HCA % jpos = j ; end if if ( name == \"HEACON\" ) then ; lp_HCO % fldo = . true .; lp_HCO % jpos = j ; end if if ( name == \"DRAIN\" ) then ; lp_DRA % fldo = . true .; lp_DRA % jpos = j ; end if if ( name == \"RWU\" ) then ; lp_RWU % fldo = . true .; lp_RWU % jpos = j ; end if if ( name == \"FLUX\" ) then ; lp_Q % fldo = . true .; lp_Q % jpos = j ; end if if ( name == \"SSDI\" ) then ; lp_SI % fldo = . true .; lp_SI % jpos = j ; end if ! Subregion: WTOT, QTRANS, QTOP, QBOT, QDRA, QTOPIN, QTOPOUT, QBOTIN, QBOTOUT, QDRAININ, QDRAINOUT if ( name == \"WTOT\" ) then ; lp_WTOT % fldo = . true .; lp_WTOT % jpos = j ; isSUB = . true .; end if if ( name == \"QTRANS\" ) then ; lp_QTRA % fldo = . true .; lp_QTRA % jpos = j ; isSUB = . true .; end if if ( name == \"QTOP\" ) then ; lp_QTOP % fldo = . true .; lp_QTOP % jpos = j ; isSUB = . true .; end if if ( name == \"QBOT\" ) then ; lp_QBOT % fldo = . true .; lp_QBOT % jpos = j ; isSUB = . true .; end if if ( name == \"QDRA\" ) then ; lp_QDRA % fldo = . true .; lp_QDRA % jpos = j ; isSUB = . true .; end if if ( name == \"QTOPIN\" ) then ; lp_QTIN % fldo = . true .; lp_QTIN % jpos = j ; isSUB = . true .; end if if ( name == \"QTOPOUT\" ) then ; lp_QTOU % fldo = . true .; lp_QTOU % jpos = j ; isSUB = . true .; end if if ( name == \"QBOTIN\" ) then ; lp_QBIN % fldo = . true .; lp_QBIN % jpos = j ; isSUB = . true .; end if if ( name == \"QBOTOUT\" ) then ; lp_QBOU % fldo = . true .; lp_QBOU % jpos = j ; isSUB = . true .; end if if ( name == \"QDRAININ\" ) then ; lp_QDIN % fldo = . true .; lp_QDIN % jpos = j ; isSUB = . true .; end if if ( name == \"QDRAINOUT\" ) then ; lp_QDOU % fldo = . true .; lp_QDOU % jpos = j ; isSUB = . true .; end if str = userlist ( i )( ipos1 + 1 : ipos2 - 1 ) call words ( str , ilw , semicolon , iwbeg , iwend , ifnd ) if (. not . isSUB ) then ! refers to specific nodes if ( ifnd > Mnodes ) call fatalerr ( \"handle_sqr_brackets\" , \"Too many nodes between [] input\" ) vars % Nnodes ( j ) = ifnd do k = 1 , ifnd call decrea ( iwar , str ( iwbeg ( k ): iwend ( k )), rv ) if ( rv <= 0.0d0 ) rv = real ( nodenumber ( rv , 1 )) vars % nodes ( k , j ) = nint ( rv ) vars % head ( k , j ) = trim ( name ) // \"[\" // trim ( str ( iwbeg ( k ): iwend ( k ))) // \"]\" end do call my_piksrt ( ifnd , vars % nodes ( 1 : ifnd , j ), vars % head ( 1 : ifnd , j )) else ! refers to sub parts of soil column if ( ifnd > Mnodes / 2 ) call fatalerr ( \"handle_sqr_brackets\" , \"Too many subregions between [] input\" ) vars % Nnodes ( j ) = ifnd ktel = 0 do k = 1 , ifnd substr = trim ( str ( iwbeg ( k ): iwend ( k ))) ipos3 = index ( substr , colon ); if ( ipos3 == 0 ) call fatalerr ( \"handle_sqr_brackets\" , \"Expecting : in subregions []\" ) call decrea ( iwar , substr ( 1 :( ipos3 - 1 )), rv ) ktel = ktel + 1 ! to do: if rv < 0; then determine nodenumber at given depth if ( rv <= 0.0d0 ) rv = real ( nodenumber ( rv , 2 )) vars % nodes ( ktel , j ) = nint ( rv ) call decrea ( iwar , substr (( ipos3 + 1 ):), rv ) ktel = ktel + 1 if ( rv <= 0.0d0 ) rv = real ( nodenumber ( rv , 1 )) vars % nodes ( ktel , j ) = nint ( rv ) vars % head ( k , j ) = trim ( name ) // \"[\" // trim ( substr ) // \"]\" end do end if end subroutine handle_sqr_brackets subroutine make_userlist ( InList ) implicit none ! global character ( len =* ), intent ( inout ) :: InList ! local integer :: i , j , k , ipos1 , ipos2 , il integer , parameter :: ilw = M integer , dimension ( ilw ) :: iwbeg , iwend character ( len = 2096 ) :: InListShort , InListTmp character ( len = 1024 ) :: str_insert character ( len = 256 ) :: str_sqr , str_item logical :: bracket , first ! function logical :: STRinARSTR ! replace , inside [] by ; ipos2 = 1 1 continue ipos1 = index ( trim ( InList ( ipos2 :)), \"[\" ) + ( ipos2 - 1 ) if ( ipos1 > ipos2 ) then ipos2 = index ( trim ( InList ( ipos1 :)), \"]\" ) + ( ipos1 - 1 ) if ( ipos2 == 0 ) call fatalerr ( \"make_userlist\" , \"Unmatched []\" ) do i = ipos1 + 1 , ipos2 - 1 if ( InList ( i : i ) == \",\" ) InList ( i : i ) = \";\" end do go to 1 end if call upperc ( Inlist ) ! replace shortnames (alias) by all accompanying names first = . true . InListShort = \"\" call words ( trim ( InList ), ilw , \",\" , iwbeg , iwend , nlist ) do i = 1 , nlist str_item = Inlist ( iwbeg ( i ): iwend ( i )) ! check for brackets bracket = . false . ipos1 = index ( str_item , \"[\" ) if ( ipos1 > 0 ) then bracket = . true . str_sqr = str_item ( ipos1 : len_trim ( str_item )) str_item = str_item ( 1 :( ipos1 - 1 )) end if ! check all shortnames do j = 1 , shorts % nsn ipos1 = index ( trim ( str_item ), trim ( shorts % alias ( j ))) if ( ipos1 == 1 . and . len_trim ( str_item ) == len_trim ( shorts % alias ( j ))) then iwbeg ( i ) = 0 ! replacement string str_insert = \"\" ; il = len_trim ( str_insert ) do k = 1 , shorts % n ( j ) call addstr ( str_insert , il , shorts % names ( j , k )) if ( bracket ) call addstr ( str_insert , il , str_sqr ) if ( k < shorts % n ( j )) call addstr ( str_insert , il , \",\" ) end do ! add items to InlistShort if ( first ) then first = . false . InListShort = trim ( str_insert ) else InListShort = trim ( InListShort ) // \",\" // trim ( str_insert ) end if end if end do end do ! combine Inlist and InlistShort (if needed) if (. not . first ) then first = . true . InListTmp = \"\" do i = 1 , nlist if ( iwbeg ( i ) > 0 ) then str_item = Inlist ( iwbeg ( i ): iwend ( i )) if ( first ) then first = . false . InListTmp = trim ( str_item ) else InListTmp = trim ( InListTmp ) // \",\" // trim ( str_item ) end if end if end do InList = trim ( InListTmp ) // \",\" // trim ( InListShort ) end if !   do j = 1, shorts%nsn !      ipos1 = index(trim(InList), trim(shorts%alias(j))) !      if (ipos1 > 0) then !         ! alias is there !         ipos2 = index(trim(InList(ipos1:)), \",\") + (ipos1-1); if (ipos2 < ipos1) ipos2 = len_trim(InList) !         str_help = trim(InList(ipos1:ipos2)) !         ipos3 = index(str_help, \"[\") !         if (ipos3 > 0) then !            ! square barckets are there !            ipos4 = index(str_help, \"]\") !            str_sqr = str_help(ipos3:ipos4) !         end if !         ! replacement string !         str_insert = \"\"; il = len_trim(str_insert) !         do k = 1, shorts%n(j) !            call addstr(str_insert, il, shorts%names(j,k)) !            if (ipos3 > 0) call addstr(str_insert, il, str_sqr) !            if (k < shorts%n(j)) call addstr(str_insert, il, \",\") !         end do !         ! replace !         if(ipos2 == len_trim(InList)) then !            Inlist = Inlist(1:ipos1-1) // trim(str_insert) !         else !            Inlist = Inlist(1:ipos1-1) // trim(str_insert) // Inlist(ipos2:) !         end if !      end if !   end do ! replace input in single string by list of individual items call words ( trim ( InList ), ilw , \",\" , iwbeg , iwend , nlist ) do i = 1 , nlist userlist ( i ) = trim ( adjustl ( InList ( iwbeg ( i ): iwend ( i )))) if (. not . STRinARSTR ( userlist ( i ), vars % name , M )) call fatalerr ( \"csv_write\" , \"Item in userlist not known in vars%name\" ) end do end subroutine make_userlist subroutine merge () implicit none ! global ! local integer :: i , j , k , m , ipos1 , ipos2 , ipos3 , ifnd character ( len = 256 ) :: help , ctmp integer , parameter :: ilw = 20 integer , dimension ( ilw ) :: iwbeg , iwend ! remove double entries 1 continue do i = 1 , nlist - 1 do j = i + 1 , nlist if ( userlist ( i ) == userlist ( j )) then do k = j , nlist - 1 userlist ( k ) = userlist ( k + 1 ) end do nlist = nlist - 1 userlist ( nlist + 1 ) = \"\" go to 1 end if end do end do ! merge within [] 2 continue do i = 1 , nlist - 1 ipos1 = index ( userlist ( i ), \"[\" ) if ( ipos1 > 0 ) then do j = i + 1 , nlist if ( userlist ( i )( 1 : ipos1 ) == userlist ( j )( 1 : ipos1 )) then ipos2 = index ( userlist ( i ), \"]\" ) ipos3 = index ( userlist ( j ), \"]\" ) userlist ( i ) = userlist ( i )( 1 : ipos2 - 1 ) // \";\" // userlist ( j )( ipos1 + 1 : ipos3 ) do k = j , nlist - 1 userlist ( k ) = userlist ( k + 1 ) end do nlist = nlist - 1 userlist ( nlist + 1 ) = \"\" go to 2 end if end do end if end do ! check doubles inside [] do i = 1 , nlist - 1 ipos1 = index ( userlist ( i ), \"[\" ) if ( ipos1 > 0 ) then ipos2 = index ( userlist ( i ), \"]\" ) help = userlist ( i )( ipos1 + 1 : ipos2 - 1 ) call words ( trim ( help ), ilw , \";\" , iwbeg , iwend , ifnd ) 3 continue do j = 1 , ifnd - 1 do k = j + 1 , ifnd if ( help ( iwbeg ( j ): iwend ( j )) == help ( iwbeg ( k ): iwend ( k ))) then do m = k , ifnd - 1 iwbeg ( m ) = iwbeg ( m + 1 ) iwend ( m ) = iwend ( m + 1 ) end do ifnd = ifnd - 1 goto 3 end if end do end do ctmp = userlist ( i )( 1 : ipos1 ) do k = 1 , ifnd ctmp = trim ( ctmp ) // help ( iwbeg ( k ): iwend ( k )) // \";\" end do ctmp = trim ( ctmp ( 1 : len_trim ( ctmp ) - 1 )) // \"]\" userlist ( i ) = trim ( ctmp ) end if end do end subroutine merge function nodenumber ( depth , iway ) !   use variables, only : zbotcp, numnod implicit none ! global real , intent ( in ) :: depth integer , intent ( in ) :: iway integer :: nodenumber ! local integer :: i if ( iway == 1 ) then i = 1 do while ( real ( zbotcp ( i )) . gt . ( depth + 1.0d-5 )) i = i + 1 if ( i > numnod ) call fatalerr ( \"nodenumber\" , \"Depth > zbotcp(numnod)\" ) end do nodenumber = i else i = 1 do while ( real ( ztopcp ( i )) . gt . ( depth + 1.0d-5 )) i = i + 1 if ( i > numnod ) call fatalerr ( \"nodenumber\" , \"Depth > ztopcp(numnod)\" ) end do nodenumber = i end if end function nodenumber end module SWAP_csv_output module SWAP_csv_output_tz private public :: csv_out_tz contains subroutine csv_out_tz ( iTask ) ! Routine designed for CSV output of user-selected vaiables (provided matching defined variables in this routine). ! Specifically for selected time-depth variables ! Contains help routines: do_write_csv; check_list; remove_sqbr; det_node; Make_Header ! import global variables contianing possible output use variables , only : pathwork , outfil , project , InList_csv_tz , tz_z1_z2 , numnod , z , zbotcp , flprintshort , date , t1900 , & h , theta , tsoil , K , cml , cmsy , c_top , HEACAP , HEACON , inqrot implicit none ! global integer , intent ( in ) :: iTask ! local (some need to be saved) ! allowed variable names: number of items in Allowed must be exactly equal to Mlist ! Since Forcheck reports an error when elements have different number of characters, all now have same length ! Must be UPPERCASE integer , parameter :: Mlist = 10 character ( len = 10 ), dimension ( Mlist ) :: Allowed character ( len = 10 ), dimension ( Mlist ) :: Units integer , dimension ( Mlist ), save :: iCSV , iPOS integer , parameter :: ilw = Mlist integer , dimension ( ilw ) :: iWbeg , iWend integer , save :: iuncsv , Nvars , nod_1 , nod_2 integer :: i , j character ( len =* ), parameter :: comma = ',' character ( len = 300 ) :: filnam character ( len = 160 ) :: filtext character ( len = 2 ) :: cval1 , cval2 character ( len = 20 ), save :: formZ , form_rea_E character ( len = 1024 ) :: Header , HeaderUnits character ( len = 20 ), dimension ( ilw ) :: listVars character ( len = 19 ) :: datexti ! when to automatically swith from F to E formatting integer , parameter :: num_d = 5 ! # of decimals; later: user input? integer , parameter :: num_w = num_d + 7 ! total width of format, for E-formatting: 7 positions are needed for \"-x.\"at start and \"E+00\" at end ! functions integer :: getun data ( Allowed ( i ), Units ( i ), i = 1 , Mlist ) / & 'H' , '(cm)' , & 'WC' , '(cm3/cm3)' , & 'TEMP' , '(deg C)' , & 'K' , '(cm/d)' , & 'CONC' , '(g/cm3 w)' , & 'CONCADS' , '(g/cm3)' , & 'O2TOP' , '(kg/m3)' , & 'HEACAP' , '(J/m3/K)' , & 'HEACON' , '(W/m/K)' , & 'RWU' , '(cm/d)' & / select case ( iTask ) case ( 1 ) ! some basic info !  Note: field width of zero in I and F edit descriptors is allowed as of Fortran95 to ensure as little space usage !        in output file as possible (Metcalf et al., 2004, Fortran 95/2003 explained, Oxford Univ. Press, p. 199) write ( cval1 , '(I0)' ) num_d write ( cval2 , '(I0)' ) num_w form_rea_E = '(A1,1P,E' // trim ( cval2 ) // '.' // trim ( cval1 ) // ')' formZ = '(A1,F0.3)' ! counter for number of records !Nlines = 0 ! make user-supplied list UPPERCASE call upperc ( InList_csv_tz ) ! Nvars en ListVars call words ( InList_csv_tz , ilw , ', ' , iWbeg , iWend , Nvars ) do i = 1 , Nvars ListVars ( i ) = InList_csv_tz ( iWbeg ( i ): iWend ( i )) end do ! check if ListVars contains valid data; determine iCSV and iPOS call check_list_tz () ! sort position in inList_csv in same way as in Allowed; ListVars is changed accordingly ! this needed since sequence in output columns are fixed by appearance in Allowed call sort_list_tz ( InList_csv_tz , ListVars , Nvars ) ! depth interval to consider if ( tz_z1_z2 ( 1 ) > 0.0d0 ) then nod_1 = 1 nod_2 = numnod else ! determine layer number of first z i = 1 do while ( zbotcp ( i ) . gt . ( tz_z1_z2 ( 1 ) + 1.0d-5 )) i = i + 1 end do nod_1 = i ! determine layer number of second z i = 1 do while ( zbotcp ( i ) . gt . ( tz_z1_z2 ( 2 ) + 1.0d-5 )) i = i + 1 end do nod_2 = i end if ! open file for output; existing file will be overwritten; formatted output !    to do: write some basic info at the top of the output file? iuncsv = getun ( 500 , 900 ) filnam = trim ( pathwork ) // trim ( outfil ) // '_output_tz.csv' open ( unit = iuncsv , file = filnam , status = 'replace' , form = 'formatted' ) ! column header Header = 'DATE,DEPTH' HeaderUnits = '*,(cm)' call make_header_tz ( ListVars , Nvars , Header ) call make_headerunits_tz ( HeaderUnits ) filtext = 'specified output data of SWAP' call writehead ( iuncsv , 1 , filnam , filtext , project ) write ( iuncsv , '(A)' ) trim ( HeaderUnits ) write ( iuncsv , '(A)' ) trim ( Header ) case ( 2 ) do j = nod_1 , nod_2 ! date and time if (. not . flprintshort ) then write ( iuncsv , '(2A)' , advance = 'no' ) trim ( date ) else ! determine date-time call dtdpst ( 'year-month-day hour:minute:seconds' , t1900 , datexti ) write ( iuncsv , '(2A)' , advance = 'no' ) trim ( datexti ) end if ! depth write ( iuncsv , formZ , advance = 'no' ) comma , z ( j ) ! all other variables ! programmer is responsible for correct correspondence between Names (and their position) in Allowed and ! actual SWAP variables as used below if ( iCSV ( 1 ) == 1 ) call do_write_csv_tz ( h ( j )) if ( iCSV ( 2 ) == 1 ) call do_write_csv_tz ( theta ( j )) if ( iCSV ( 3 ) == 1 ) call do_write_csv_tz ( tsoil ( j )) if ( iCSV ( 4 ) == 1 ) call do_write_csv_tz ( k ( j )) if ( iCSV ( 5 ) == 1 ) call do_write_csv_tz ( cml ( j )) if ( iCSV ( 6 ) == 1 ) call do_write_csv_tz ( cmsy ( j )) if ( iCSV ( 7 ) == 1 ) call do_write_csv_tz ( c_top ( j )) if ( iCSV ( 8 ) == 1 ) call do_write_csv_tz ( HEACAP ( j ) / 1.0d-6 ) ! from J/cm3/K  to J/m3/K if ( iCSV ( 9 ) == 1 ) call do_write_csv_tz ( HEACON ( j ) / 86 4.0d0 ) ! from J/cm/K/d to W/m/K if ( iCSV ( 10 ) == 1 ) call do_write_csv_tz ( inqrot ( j )) ! finalize record (advance to next line) write ( iuncsv , * ) end do case ( 3 ) close ( unit = iuncsv ) case default call fatalerr ( 'csv_write_tz' , 'Illegal iTask value; range allowed: [1-3]' ) end select return contains subroutine do_write_csv_tz ( var ) implicit none real ( 8 ), intent ( in ) :: var write ( iuncsv , form_rea_E , advance = 'no' ) comma , real ( var ) end subroutine do_write_csv_tz subroutine check_list_tz () implicit none integer :: i , j logical :: isthere iCSV = 0 iPOS = 0 do i = 1 , Nvars isthere = . false . do j = 1 , Mlist isthere = trim ( ListVars ( i )) == trim ( Allowed ( j )) if ( isthere ) then iCSV ( j ) = 1 ! indicator for Yes/No for writing if ( iPOS ( j ) > 0 ) call fatalerr ( 'check_list_tz' , 'Double entries in inList_csv_tz are not allowed' ) iPOS ( j ) = i ! help vector to be used later for sorting exit end if end do ! error if not there; or should we write a warning? if (. not . isthere ) call fatalerr ( 'check_list_tz' , 'Illegal variable name in inList_csv_tz for write_csv output' ) end do end subroutine check_list_tz subroutine sort_list_tz ( InList_csv , ListVars , Nvars ) implicit none ! global; NB: on output both variables are arranged in same sorted order as Allowed integer , intent ( in ) :: Nvars character ( len =* ), intent ( out ) :: InList_csv character ( len =* ), dimension ( Nvars ), intent ( inout ) :: ListVars ! local integer :: il , i , j character ( len = 1024 ) :: temp il = 0 ! iPOS contains for each of the Allowed names the position in the user-supplied list ListVars, ! and adds this to a temporary string do j = 1 , Mlist if ( iPOS ( j ) > 0 ) then if ( il == 0 ) then temp = trim ( listVars ( iPOS ( j ))); il = len_trim ( temp ) else temp = temp ( 1 : il ) // comma // trim ( listVars ( iPOS ( j ))); il = len_trim ( temp ) end if end if end do ! temp now contains the user-supplied names in the same order of appearance is in Allowed ! decompose temp into ListVars (overwrite) call words ( temp , ilw , comma , iWbeg , iWend , Nvars ) do i = 1 , Nvars ListVars ( i ) = temp ( iWbeg ( i ): iWend ( i )) end do ! on return: InList_csv becomes equal to sorted string temp InList_csv = trim ( temp ) end subroutine sort_list_tz subroutine Make_Header_tz ( ListVars , Nvars , Header ) implicit none ! global integer , intent ( in ) :: Nvars character ( len =* ), dimension ( Nvars ), intent ( in ) :: ListVars character ( len =* ), intent ( inout ) :: Header ! local integer :: i , il il = len_trim ( Header ) do i = 1 , Nvars Header = Header ( 1 : il ) // \",\" // trim ( ListVars ( i )); il = len_trim ( Header ) end do end subroutine Make_Header_tz subroutine make_headerunits_tz ( HeaderUnits ) implicit none ! global character ( len =* ), intent ( inout ) :: HeaderUnits ! local integer :: i , il il = len_trim ( HeaderUnits ) do i = 1 , Mlist if ( iCSV ( i ) == 1 ) then HeaderUnits = HeaderUnits ( 1 : il ) // \",\" // trim ( Units ( i )); il = len_trim ( HeaderUnits ) end if end do end subroutine make_headerunits_tz end subroutine csv_out_tz end module SWAP_csv_output_tz function STRinARSTR ( string , arraystring , N ) implicit none ! global integer , intent ( in ) :: N character ( len =* ), intent ( in ) :: string character ( len =* ), dimension ( N ), intent ( in ) :: arraystring logical :: STRinARSTR ! local integer :: i , il , ip STRinARSTR = . false . do i = 1 , N il = len_trim ( trim ( string )) ip = index ( string , \"[\" ) if ( ip > 0 ) il = ip if ( trim ( string ( 1 : il )) == trim ( arraystring ( i ))) then STRinARSTR = . true . exit end if end do end function STRinARSTR subroutine writeheader ( iun ) implicit none integer , intent ( in ) :: iun write ( iun , '(A)' ) '* Project:       ' write ( iun , '(A)' ) '* File content:  ' write ( iun , '(A)' ) '* File name:     ' write ( iun , '(A)' ) '* Model version: ' write ( iun , '(A)' ) '* Generated at:  ' end subroutine writeheader SUBROUTINE my_piksrt ( n , arr , brr ) ! adapted after Numerical Recipes routine piksr2 (inputs now 1 integer and 1 char arrays) implicit none ! global INTEGER , intent ( in ) :: n integer , dimension ( n ), intent ( inout ) :: arr character ( len =* ), dimension ( n ), intent ( inout ) :: brr ! local INTEGER :: i , j , a character ( len = 80 ) :: b do j = 2 , n a = arr ( j ) b = brr ( j ) do i = j - 1 , 1 , - 1 if ( arr ( i ) <= a ) goto 10 arr ( i + 1 ) = arr ( i ) brr ( i + 1 ) = brr ( i ) end do i = 0 10 arr ( i + 1 ) = a brr ( i + 1 ) = b end do return END","tags":"","loc":"sourcefile/swap_csv_output.f90.html"}]}